{"version":3,"file":"index.mjs","sources":["../../src/utils.ts","../../src/typeGuards.ts","../../src/sanitization.ts","../../src/gemini/index.ts"],"sourcesContent":["import { PostHog } from 'posthog-node'\nimport { Buffer } from 'buffer'\nimport OpenAIOrignal from 'openai'\nimport AnthropicOriginal from '@anthropic-ai/sdk'\nimport type { ChatCompletionTool } from 'openai/resources/chat/completions'\nimport type { ResponseCreateParamsWithTools } from 'openai/lib/ResponsesParser'\nimport type { Tool as GeminiTool } from '@google/genai'\nimport type { FormattedMessage, FormattedContent, TokenUsage } from './types'\nimport { version } from '../package.json'\nimport { v4 as uuidv4 } from 'uuid'\n\ntype ChatCompletionCreateParamsBase = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams\ntype MessageCreateParams = AnthropicOriginal.Messages.MessageCreateParams\ntype ResponseCreateParams = OpenAIOrignal.Responses.ResponseCreateParams\ntype EmbeddingCreateParams = OpenAIOrignal.EmbeddingCreateParams\ntype AnthropicTool = AnthropicOriginal.Tool\n\n// limit large outputs by truncating to 200kb (approx 200k bytes)\nexport const MAX_OUTPUT_SIZE = 200000\nconst STRING_FORMAT = 'utf8'\n\nexport interface MonitoringEventPropertiesWithDefaults {\n  distinctId?: string\n  traceId: string\n  properties?: Record<string, any>\n  privacyMode: boolean\n  groups?: Record<string, any>\n  modelOverride?: string\n  providerOverride?: string\n  costOverride?: CostOverride\n  captureImmediate?: boolean\n}\n\nexport type MonitoringEventProperties = Partial<MonitoringEventPropertiesWithDefaults>\n\nexport type MonitoringParams = {\n  [K in keyof MonitoringEventProperties as `posthog${Capitalize<string & K>}`]: MonitoringEventProperties[K]\n}\n\nexport interface CostOverride {\n  inputCost: number\n  outputCost: number\n}\n\nexport const getModelParams = (\n  params:\n    | ((\n        | ChatCompletionCreateParamsBase\n        | MessageCreateParams\n        | ResponseCreateParams\n        | ResponseCreateParamsWithTools\n        | EmbeddingCreateParams\n      ) &\n        MonitoringParams)\n    | null\n): Record<string, any> => {\n  if (!params) {\n    return {}\n  }\n  const modelParams: Record<string, any> = {}\n  const paramKeys = [\n    'temperature',\n    'max_tokens',\n    'max_completion_tokens',\n    'top_p',\n    'frequency_penalty',\n    'presence_penalty',\n    'n',\n    'stop',\n    'stream',\n    'streaming',\n  ] as const\n\n  for (const key of paramKeys) {\n    if (key in params && (params as any)[key] !== undefined) {\n      modelParams[key] = (params as any)[key]\n    }\n  }\n  return modelParams\n}\n\n/**\n * Helper to format responses (non-streaming) for consumption, mirroring Python's openai vs. anthropic approach.\n */\nexport const formatResponse = (response: any, provider: string): FormattedMessage[] => {\n  if (!response) {\n    return []\n  }\n  if (provider === 'anthropic') {\n    return formatResponseAnthropic(response)\n  } else if (provider === 'openai') {\n    return formatResponseOpenAI(response)\n  } else if (provider === 'gemini') {\n    return formatResponseGemini(response)\n  }\n  return []\n}\n\nexport const formatResponseAnthropic = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n  const content: FormattedContent = []\n\n  for (const choice of response.content ?? []) {\n    if (choice?.type === 'text' && choice?.text) {\n      content.push({ type: 'text', text: choice.text })\n    } else if (choice?.type === 'tool_use' && choice?.name && choice?.id) {\n      content.push({\n        type: 'function',\n        id: choice.id,\n        function: {\n          name: choice.name,\n          arguments: choice.input || {},\n        },\n      })\n    }\n  }\n\n  if (content.length > 0) {\n    output.push({\n      role: 'assistant',\n      content,\n    })\n  }\n\n  return output\n}\n\nexport const formatResponseOpenAI = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.choices) {\n    for (const choice of response.choices) {\n      const content: FormattedContent = []\n      let role = 'assistant'\n\n      if (choice.message) {\n        if (choice.message.role) {\n          role = choice.message.role\n        }\n\n        if (choice.message.content) {\n          content.push({ type: 'text', text: choice.message.content })\n        }\n\n        if (choice.message.tool_calls) {\n          for (const toolCall of choice.message.tool_calls) {\n            content.push({\n              type: 'function',\n              id: toolCall.id,\n              function: {\n                name: toolCall.function.name,\n                arguments: toolCall.function.arguments,\n              },\n            })\n          }\n        }\n      }\n\n      if (content.length > 0) {\n        output.push({\n          role,\n          content,\n        })\n      }\n    }\n  }\n\n  // Handle Responses API format\n  if (response.output) {\n    const content: FormattedContent = []\n    let role = 'assistant'\n\n    for (const item of response.output) {\n      if (item.type === 'message') {\n        role = item.role\n\n        if (item.content && Array.isArray(item.content)) {\n          for (const contentItem of item.content) {\n            if (contentItem.type === 'output_text' && contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.type === 'input_image' && contentItem.image_url) {\n              content.push({\n                type: 'image',\n                image: contentItem.image_url,\n              })\n            }\n          }\n        } else if (item.content) {\n          content.push({ type: 'text', text: String(item.content) })\n        }\n      } else if (item.type === 'function_call') {\n        content.push({\n          type: 'function',\n          id: item.call_id || item.id || '',\n          function: {\n            name: item.name,\n            arguments: item.arguments || {},\n          },\n        })\n      }\n    }\n\n    if (content.length > 0) {\n      output.push({\n        role,\n        content,\n      })\n    }\n  }\n\n  return output\n}\n\nexport const formatResponseGemini = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.candidates && Array.isArray(response.candidates)) {\n    for (const candidate of response.candidates) {\n      if (candidate.content && candidate.content.parts) {\n        const content: FormattedContent = []\n\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            content.push({ type: 'text', text: part.text })\n          } else if (part.functionCall) {\n            content.push({\n              type: 'function',\n              function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args,\n              },\n            })\n          }\n        }\n\n        if (content.length > 0) {\n          output.push({\n            role: 'assistant',\n            content,\n          })\n        }\n      } else if (candidate.text) {\n        output.push({\n          role: 'assistant',\n          content: [{ type: 'text', text: candidate.text }],\n        })\n      }\n    }\n  } else if (response.text) {\n    output.push({\n      role: 'assistant',\n      content: [{ type: 'text', text: response.text }],\n    })\n  }\n\n  return output\n}\n\nexport const mergeSystemPrompt = (params: MessageCreateParams & MonitoringParams, provider: string): any => {\n  if (provider == 'anthropic') {\n    const messages = params.messages || []\n    if (!(params as any).system) {\n      return messages\n    }\n    const systemMessage = (params as any).system\n    return [{ role: 'system', content: systemMessage }, ...messages]\n  }\n  return params.messages\n}\n\nexport const withPrivacyMode = (client: PostHog, privacyMode: boolean, input: any): any => {\n  return (client as any).privacy_mode || privacyMode ? null : input\n}\n\nfunction toSafeString(input: unknown): string {\n  if (input === undefined || input === null) {\n    return ''\n  }\n  if (typeof input === 'string') {\n    return input\n  }\n  try {\n    return JSON.stringify(input)\n  } catch {\n    console.warn('Failed to stringify input', input)\n    return ''\n  }\n}\n\nexport const truncate = (input: unknown): string => {\n  const str = toSafeString(input)\n  if (str === '') {\n    return ''\n  }\n\n  // Check if we need to truncate and ensure STRING_FORMAT is respected\n  const encoder = new TextEncoder()\n  const buffer = encoder.encode(str)\n  if (buffer.length <= MAX_OUTPUT_SIZE) {\n    // Ensure STRING_FORMAT is respected\n    return new TextDecoder(STRING_FORMAT).decode(buffer)\n  }\n\n  // Truncate the buffer and ensure a valid string is returned\n  const truncatedBuffer = buffer.slice(0, MAX_OUTPUT_SIZE)\n  // fatal: false means we get U+FFFD at the end if truncation broke the encoding\n  const decoder = new TextDecoder(STRING_FORMAT, { fatal: false })\n  let truncatedStr = decoder.decode(truncatedBuffer)\n  if (truncatedStr.endsWith('\\uFFFD')) {\n    truncatedStr = truncatedStr.slice(0, -1)\n  }\n  return `${truncatedStr}... [truncated]`\n}\n\n/**\n * Extract available tool calls from the request parameters.\n * These are the tools provided to the LLM, not the tool calls in the response.\n */\nexport const extractAvailableToolCalls = (\n  provider: string,\n  params: any\n): ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null => {\n  if (provider === 'anthropic') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'gemini') {\n    if (params.config && params.config.tools) {\n      return params.config.tools\n    }\n\n    return null\n  } else if (provider === 'openai') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'vercel') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  }\n\n  return null\n}\n\nexport enum AIEvent {\n  Generation = '$ai_generation',\n  Embedding = '$ai_embedding',\n}\n\nexport type SendEventToPosthogParams = {\n  client: PostHog\n  eventType?: AIEvent\n  distinctId?: string\n  traceId: string\n  model: string\n  provider: string\n  input: any\n  output: any\n  latency: number\n  baseURL: string\n  httpStatus: number\n  usage?: TokenUsage\n  params: (\n    | ChatCompletionCreateParamsBase\n    | MessageCreateParams\n    | ResponseCreateParams\n    | ResponseCreateParamsWithTools\n    | EmbeddingCreateParams\n  ) &\n    MonitoringParams\n  isError?: boolean\n  error?: string\n  tools?: ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null\n  captureImmediate?: boolean\n}\n\nfunction sanitizeValues(obj: any): any {\n  if (obj === undefined || obj === null) {\n    return obj\n  }\n  const jsonSafe = JSON.parse(JSON.stringify(obj))\n  if (typeof jsonSafe === 'string') {\n    return Buffer.from(jsonSafe, STRING_FORMAT).toString(STRING_FORMAT)\n  } else if (Array.isArray(jsonSafe)) {\n    return jsonSafe.map(sanitizeValues)\n  } else if (jsonSafe && typeof jsonSafe === 'object') {\n    return Object.fromEntries(Object.entries(jsonSafe).map(([k, v]) => [k, sanitizeValues(v)]))\n  }\n  return jsonSafe\n}\n\nconst POSTHOG_PARAMS_MAP: Record<keyof MonitoringParams, string> = {\n  posthogDistinctId: 'distinctId',\n  posthogTraceId: 'traceId',\n  posthogProperties: 'properties',\n  posthogPrivacyMode: 'privacyMode',\n  posthogGroups: 'groups',\n  posthogModelOverride: 'modelOverride',\n  posthogProviderOverride: 'providerOverride',\n  posthogCostOverride: 'costOverride',\n  posthogCaptureImmediate: 'captureImmediate',\n}\n\nexport function extractPosthogParams<T>(body: T & MonitoringParams): {\n  providerParams: T\n  posthogParams: MonitoringEventPropertiesWithDefaults\n} {\n  const providerParams: Record<string, unknown> = {}\n  const posthogParams: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(body)) {\n    if (POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]) {\n      posthogParams[POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]] = value\n    } else if (key.startsWith('posthog')) {\n      console.warn(`Unknown Posthog parameter ${key}`)\n    } else {\n      providerParams[key] = value\n    }\n  }\n\n  return {\n    providerParams: providerParams as T,\n    posthogParams: addDefaults(posthogParams),\n  }\n}\n\nfunction addDefaults(params: MonitoringEventProperties): MonitoringEventPropertiesWithDefaults {\n  return {\n    ...params,\n    privacyMode: params.privacyMode ?? false,\n    traceId: params.traceId ?? uuidv4(),\n  }\n}\n\nexport const sendEventToPosthog = async ({\n  client,\n  eventType = AIEvent.Generation,\n  distinctId,\n  traceId,\n  model,\n  provider,\n  input,\n  output,\n  latency,\n  baseURL,\n  params,\n  httpStatus = 200,\n  usage = {},\n  isError = false,\n  error,\n  tools,\n  captureImmediate = false,\n}: SendEventToPosthogParams): Promise<void> => {\n  if (!client.capture) {\n    return Promise.resolve()\n  }\n  // sanitize input and output for UTF-8 validity\n  const safeInput = sanitizeValues(input)\n  const safeOutput = sanitizeValues(output)\n  const safeError = sanitizeValues(error)\n\n  let errorData = {}\n  if (isError) {\n    errorData = {\n      $ai_is_error: true,\n      $ai_error: safeError,\n    }\n  }\n  let costOverrideData = {}\n  if (params.posthogCostOverride) {\n    const inputCostUSD = (params.posthogCostOverride.inputCost ?? 0) * (usage.inputTokens ?? 0)\n    const outputCostUSD = (params.posthogCostOverride.outputCost ?? 0) * (usage.outputTokens ?? 0)\n    costOverrideData = {\n      $ai_input_cost_usd: inputCostUSD,\n      $ai_output_cost_usd: outputCostUSD,\n      $ai_total_cost_usd: inputCostUSD + outputCostUSD,\n    }\n  }\n\n  const additionalTokenValues = {\n    ...(usage.reasoningTokens ? { $ai_reasoning_tokens: usage.reasoningTokens } : {}),\n    ...(usage.cacheReadInputTokens ? { $ai_cache_read_input_tokens: usage.cacheReadInputTokens } : {}),\n    ...(usage.cacheCreationInputTokens ? { $ai_cache_creation_input_tokens: usage.cacheCreationInputTokens } : {}),\n  }\n\n  const properties = {\n    $ai_lib: 'posthog-ai',\n    $ai_lib_version: version,\n    $ai_provider: params.posthogProviderOverride ?? provider,\n    $ai_model: params.posthogModelOverride ?? model,\n    $ai_model_parameters: getModelParams(params),\n    $ai_input: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeInput),\n    $ai_output_choices: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeOutput),\n    $ai_http_status: httpStatus,\n    $ai_input_tokens: usage.inputTokens ?? 0,\n    ...(usage.outputTokens !== undefined ? { $ai_output_tokens: usage.outputTokens } : {}),\n    ...additionalTokenValues,\n    $ai_latency: latency,\n    $ai_trace_id: traceId,\n    $ai_base_url: baseURL,\n    ...params.posthogProperties,\n    ...(distinctId ? {} : { $process_person_profile: false }),\n    ...(tools ? { $ai_tools: tools } : {}),\n    ...errorData,\n    ...costOverrideData,\n  }\n\n  const event = {\n    distinctId: distinctId ?? traceId,\n    event: eventType,\n    properties,\n    groups: params.posthogGroups,\n  }\n\n  if (captureImmediate) {\n    // await capture promise to send single event in serverless environments\n    await client.captureImmediate(event)\n  } else {\n    client.capture(event)\n  }\n}\n","// Type guards for safer type checking\n\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string'\n}\n\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isString, isObject } from './typeGuards'\n\nconst REDACTED_IMAGE_PLACEHOLDER = '[base64 image redacted]'\n\n// ============================================\n// Base64 Detection Helpers\n// ============================================\n\nconst isBase64DataUrl = (str: string): boolean => {\n  return /^data:([^;]+);base64,/.test(str)\n}\n\nconst isValidUrl = (str: string): boolean => {\n  try {\n    new URL(str)\n    return true\n  } catch {\n    // Not an absolute URL, check if it's a relative URL or path\n    return str.startsWith('/') || str.startsWith('./') || str.startsWith('../')\n  }\n}\n\nconst isRawBase64 = (str: string): boolean => {\n  // Skip if it's a valid URL or path\n  if (isValidUrl(str)) {\n    return false\n  }\n\n  // Check if it's a valid base64 string\n  // Base64 images are typically at least a few hundred chars, but we'll be conservative\n  return str.length > 20 && /^[A-Za-z0-9+/]+=*$/.test(str)\n}\n\nexport function redactBase64DataUrl(str: string): string\nexport function redactBase64DataUrl(str: unknown): unknown\nexport function redactBase64DataUrl(str: unknown): unknown {\n  if (!isString(str)) return str\n\n  // Check for data URL format\n  if (isBase64DataUrl(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  // Check for raw base64 (Vercel sends raw base64 for inline images)\n  if (isRawBase64(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  return str\n}\n\n// ============================================\n// Common Message Processing\n// ============================================\n\ntype ContentTransformer = (item: unknown) => unknown\n\nconst processMessages = (messages: unknown, transformContent: ContentTransformer): unknown => {\n  if (!messages) return messages\n\n  const processContent = (content: unknown): unknown => {\n    if (typeof content === 'string') return content\n\n    if (!content) return content\n\n    if (Array.isArray(content)) {\n      return content.map(transformContent)\n    }\n\n    // Handle single object content\n    return transformContent(content)\n  }\n\n  const processMessage = (msg: unknown): unknown => {\n    if (!isObject(msg) || !('content' in msg)) return msg\n    return { ...msg, content: processContent(msg.content) }\n  }\n\n  // Handle both arrays and single messages\n  if (Array.isArray(messages)) {\n    return messages.map(processMessage)\n  }\n\n  return processMessage(messages)\n}\n\n// ============================================\n// Provider-Specific Image Sanitizers\n// ============================================\n\nconst sanitizeOpenAIImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle image_url format\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeOpenAIResponseImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle input_image format\n  if (item.type === 'input_image' && 'image_url' in item) {\n    return {\n      ...item,\n      image_url: redactBase64DataUrl(item.image_url),\n    }\n  }\n\n  return item\n}\n\nconst sanitizeAnthropicImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle Anthropic's image format\n  if (\n    item.type === 'image' &&\n    'source' in item &&\n    isObject(item.source) &&\n    item.source.type === 'base64' &&\n    'data' in item.source\n  ) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeGeminiPart = (part: unknown): unknown => {\n  if (!isObject(part)) return part\n\n  // Handle Gemini's inline data format\n  if ('inlineData' in part && isObject(part.inlineData) && 'data' in part.inlineData) {\n    return {\n      ...part,\n      inlineData: {\n        ...part.inlineData,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return part\n}\n\nconst processGeminiItem = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // If it has parts, process them\n  if ('parts' in item && item.parts) {\n    const parts = Array.isArray(item.parts) ? item.parts.map(sanitizeGeminiPart) : sanitizeGeminiPart(item.parts)\n\n    return { ...item, parts }\n  }\n\n  return item\n}\n\nconst sanitizeLangChainImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // OpenAI style\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  // Direct image with data field\n  if (item.type === 'image' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  // Anthropic style\n  if (item.type === 'image' && 'source' in item && isObject(item.source) && 'data' in item.source) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: redactBase64DataUrl(item.source.data),\n      },\n    }\n  }\n\n  // Google style\n  if (item.type === 'media' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  return item\n}\n\n// Export individual sanitizers for tree-shaking\nexport const sanitizeOpenAI = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIImage)\n}\n\nexport const sanitizeOpenAIResponse = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIResponseImage)\n}\n\nexport const sanitizeAnthropic = (data: unknown): unknown => {\n  return processMessages(data, sanitizeAnthropicImage)\n}\n\nexport const sanitizeGemini = (data: unknown): unknown => {\n  // Gemini has a different structure with 'parts' directly on items instead of 'content'\n  // So we need custom processing instead of using processMessages\n  if (!data) return data\n\n  if (Array.isArray(data)) {\n    return data.map(processGeminiItem)\n  }\n\n  return processGeminiItem(data)\n}\n\nexport const sanitizeLangChain = (data: unknown): unknown => {\n  return processMessages(data, sanitizeLangChainImage)\n}\n","import {\n  GoogleGenAI,\n  GenerateContentResponse as GeminiResponse,\n  GenerateContentParameters,\n  Part,\n  GenerateContentResponseUsageMetadata,\n} from '@google/genai'\nimport { PostHog } from 'posthog-node'\nimport {\n  MonitoringParams,\n  sendEventToPosthog,\n  extractAvailableToolCalls,\n  formatResponseGemini,\n  extractPosthogParams,\n} from '../utils'\nimport { sanitizeGemini } from '../sanitization'\nimport type { TokenUsage, FormattedContent, FormattedContentItem, FormattedMessage } from '../types'\n\ninterface MonitoringGeminiConfig {\n  apiKey?: string\n  vertexai?: boolean\n  project?: string\n  location?: string\n  apiVersion?: string\n  posthog: PostHog\n}\n\nexport class PostHogGoogleGenAI {\n  private readonly phClient: PostHog\n  private readonly client: GoogleGenAI\n  public models: WrappedModels\n\n  constructor(config: MonitoringGeminiConfig) {\n    const { posthog, ...geminiConfig } = config\n    this.phClient = posthog\n    this.client = new GoogleGenAI(geminiConfig)\n    this.models = new WrappedModels(this.client, this.phClient)\n  }\n}\n\nexport class WrappedModels {\n  private readonly phClient: PostHog\n  private readonly client: GoogleGenAI\n\n  constructor(client: GoogleGenAI, phClient: PostHog) {\n    this.client = client\n    this.phClient = phClient\n  }\n\n  public async generateContent(params: GenerateContentParameters & MonitoringParams): Promise<GeminiResponse> {\n    const { providerParams: geminiParams, posthogParams } = extractPosthogParams(params)\n    const startTime = Date.now()\n\n    try {\n      const response = await this.client.models.generateContent(geminiParams as GenerateContentParameters)\n      const latency = (Date.now() - startTime) / 1000\n\n      const availableTools = extractAvailableToolCalls('gemini', geminiParams)\n\n      const metadata = response.usageMetadata\n      await sendEventToPosthog({\n        client: this.phClient,\n        ...posthogParams,\n        model: geminiParams.model,\n        provider: 'gemini',\n        input: this.formatInputForPostHog(geminiParams.contents),\n        output: formatResponseGemini(response),\n        latency,\n        baseURL: 'https://generativelanguage.googleapis.com',\n        params: params as GenerateContentParameters & MonitoringParams,\n        httpStatus: 200,\n        usage: {\n          inputTokens: metadata?.promptTokenCount ?? 0,\n          outputTokens: metadata?.candidatesTokenCount ?? 0,\n          reasoningTokens:\n            (metadata as GenerateContentResponseUsageMetadata & { thoughtsTokenCount?: number })?.thoughtsTokenCount ??\n            0,\n          cacheReadInputTokens: metadata?.cachedContentTokenCount ?? 0,\n        },\n        tools: availableTools,\n      })\n\n      return response\n    } catch (error: unknown) {\n      const latency = (Date.now() - startTime) / 1000\n      await sendEventToPosthog({\n        client: this.phClient,\n        ...posthogParams,\n        model: geminiParams.model,\n        provider: 'gemini',\n        input: this.formatInputForPostHog(geminiParams.contents),\n        output: [],\n        latency,\n        baseURL: 'https://generativelanguage.googleapis.com',\n        params: params as GenerateContentParameters & MonitoringParams,\n        httpStatus: (error as { status?: number })?.status ?? 500,\n        usage: {\n          inputTokens: 0,\n          outputTokens: 0,\n        },\n        isError: true,\n        error: JSON.stringify(error),\n      })\n      throw error\n    }\n  }\n\n  public async *generateContentStream(\n    params: GenerateContentParameters & MonitoringParams\n  ): AsyncGenerator<GeminiResponse, void, unknown> {\n    const { providerParams: geminiParams, posthogParams } = extractPosthogParams(params)\n    const startTime = Date.now()\n    const accumulatedContent: FormattedContent = []\n    let usage: TokenUsage = {\n      inputTokens: 0,\n      outputTokens: 0,\n    }\n\n    try {\n      const stream = await this.client.models.generateContentStream(geminiParams as GenerateContentParameters)\n\n      for await (const chunk of stream) {\n        // Handle text content\n        if (chunk.text) {\n          // Find if we already have a text item to append to\n          let lastTextItem: FormattedContentItem | undefined\n          for (let i = accumulatedContent.length - 1; i >= 0; i--) {\n            if (accumulatedContent[i].type === 'text') {\n              lastTextItem = accumulatedContent[i]\n              break\n            }\n          }\n\n          if (lastTextItem && lastTextItem.type === 'text') {\n            lastTextItem.text += chunk.text\n          } else {\n            accumulatedContent.push({ type: 'text', text: chunk.text })\n          }\n        }\n\n        // Handle function calls from candidates\n        if (chunk.candidates && Array.isArray(chunk.candidates)) {\n          for (const candidate of chunk.candidates) {\n            if (candidate.content && candidate.content.parts) {\n              for (const part of candidate.content.parts) {\n                // Type-safe check for functionCall\n                if ('functionCall' in part) {\n                  const funcCall = (part as Part & { functionCall?: { name?: string; args?: unknown } }).functionCall\n                  if (funcCall?.name) {\n                    accumulatedContent.push({\n                      type: 'function',\n                      function: {\n                        name: funcCall.name,\n                        arguments: funcCall.args || {},\n                      },\n                    })\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Update usage metadata - handle both old and new field names\n        if (chunk.usageMetadata) {\n          const metadata = chunk.usageMetadata as GenerateContentResponseUsageMetadata\n          usage = {\n            inputTokens: metadata.promptTokenCount ?? 0,\n            outputTokens: metadata.candidatesTokenCount ?? 0,\n            reasoningTokens:\n              (metadata as GenerateContentResponseUsageMetadata & { thoughtsTokenCount?: number }).thoughtsTokenCount ??\n              0,\n            cacheReadInputTokens: metadata.cachedContentTokenCount ?? 0,\n          }\n        }\n        yield chunk\n      }\n\n      const latency = (Date.now() - startTime) / 1000\n\n      const availableTools = extractAvailableToolCalls('gemini', geminiParams)\n\n      // Format output similar to formatResponseGemini\n      const output = accumulatedContent.length > 0 ? [{ role: 'assistant', content: accumulatedContent }] : []\n\n      await sendEventToPosthog({\n        client: this.phClient,\n        ...posthogParams,\n        model: geminiParams.model,\n        provider: 'gemini',\n        input: this.formatInputForPostHog(geminiParams.contents),\n        output,\n        latency,\n        baseURL: 'https://generativelanguage.googleapis.com',\n        params: params as GenerateContentParameters & MonitoringParams,\n        httpStatus: 200,\n        usage,\n        tools: availableTools,\n      })\n    } catch (error: unknown) {\n      const latency = (Date.now() - startTime) / 1000\n      await sendEventToPosthog({\n        client: this.phClient,\n        ...posthogParams,\n        model: geminiParams.model,\n        provider: 'gemini',\n        input: this.formatInputForPostHog(geminiParams.contents),\n        output: [],\n        latency,\n        baseURL: 'https://generativelanguage.googleapis.com',\n        params: params as GenerateContentParameters & MonitoringParams,\n        httpStatus: (error as { status?: number })?.status ?? 500,\n        usage: {\n          inputTokens: 0,\n          outputTokens: 0,\n        },\n        isError: true,\n        error: JSON.stringify(error),\n      })\n      throw error\n    }\n  }\n\n  private formatInput(contents: unknown): FormattedMessage[] {\n    if (typeof contents === 'string') {\n      return [{ role: 'user', content: contents }]\n    }\n\n    if (Array.isArray(contents)) {\n      return contents.map((item) => {\n        if (typeof item === 'string') {\n          return { role: 'user', content: item }\n        }\n\n        if (item && typeof item === 'object') {\n          const obj = item as Record<string, unknown>\n          if ('text' in obj && obj.text) {\n            return { role: (obj.role as string) || 'user', content: obj.text }\n          }\n\n          if ('content' in obj && obj.content) {\n            return { role: (obj.role as string) || 'user', content: obj.content }\n          }\n\n          if ('parts' in obj && Array.isArray(obj.parts)) {\n            return {\n              role: (obj.role as string) || 'user',\n              content: obj.parts.map((part: unknown) => {\n                if (part && typeof part === 'object' && 'text' in part) {\n                  return (part as { text: unknown }).text\n                }\n                return part\n              }),\n            }\n          }\n        }\n\n        return { role: 'user', content: String(item) }\n      })\n    }\n\n    if (contents && typeof contents === 'object') {\n      const obj = contents as Record<string, unknown>\n      if ('text' in obj && obj.text) {\n        return [{ role: 'user', content: obj.text }]\n      }\n\n      if ('content' in obj && obj.content) {\n        return [{ role: 'user', content: obj.content }]\n      }\n    }\n\n    return [{ role: 'user', content: String(contents) }]\n  }\n\n  private formatInputForPostHog(contents: unknown): unknown {\n    const sanitized = sanitizeGemini(contents)\n    return this.formatInput(sanitized)\n  }\n}\n\nexport default PostHogGoogleGenAI\nexport { PostHogGoogleGenAI as Gemini }\n"],"names":["STRING_FORMAT","getModelParams","params","modelParams","paramKeys","key","undefined","formatResponseGemini","response","output","candidates","Array","isArray","candidate","content","parts","part","text","push","type","functionCall","function","name","arguments","args","length","role","withPrivacyMode","client","privacyMode","input","privacy_mode","extractAvailableToolCalls","provider","config","tools","AIEvent","sanitizeValues","obj","jsonSafe","JSON","parse","stringify","Buffer","from","toString","map","Object","fromEntries","entries","k","v","POSTHOG_PARAMS_MAP","posthogDistinctId","posthogTraceId","posthogProperties","posthogPrivacyMode","posthogGroups","posthogModelOverride","posthogProviderOverride","posthogCostOverride","posthogCaptureImmediate","extractPosthogParams","body","providerParams","posthogParams","value","startsWith","console","warn","addDefaults","traceId","uuidv4","sendEventToPosthog","eventType","Generation","distinctId","model","latency","baseURL","httpStatus","usage","isError","error","captureImmediate","capture","Promise","resolve","safeInput","safeOutput","safeError","errorData","$ai_is_error","$ai_error","costOverrideData","inputCostUSD","inputCost","inputTokens","outputCostUSD","outputCost","outputTokens","$ai_input_cost_usd","$ai_output_cost_usd","$ai_total_cost_usd","additionalTokenValues","reasoningTokens","$ai_reasoning_tokens","cacheReadInputTokens","$ai_cache_read_input_tokens","cacheCreationInputTokens","$ai_cache_creation_input_tokens","properties","$ai_lib","$ai_lib_version","version","$ai_provider","$ai_model","$ai_model_parameters","$ai_input","$ai_output_choices","$ai_http_status","$ai_input_tokens","$ai_output_tokens","$ai_latency","$ai_trace_id","$ai_base_url","$process_person_profile","$ai_tools","event","groups","isObject","REDACTED_IMAGE_PLACEHOLDER","sanitizeGeminiPart","inlineData","data","processGeminiItem","item","sanitizeGemini","PostHogGoogleGenAI","constructor","posthog","geminiConfig","phClient","GoogleGenAI","models","WrappedModels","generateContent","geminiParams","startTime","Date","now","availableTools","metadata","usageMetadata","formatInputForPostHog","contents","promptTokenCount","candidatesTokenCount","thoughtsTokenCount","cachedContentTokenCount","status","generateContentStream","accumulatedContent","stream","chunk","lastTextItem","i","funcCall","formatInput","String","sanitized"],"mappings":"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"}