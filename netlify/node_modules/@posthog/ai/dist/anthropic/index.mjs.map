{"version":3,"file":"index.mjs","sources":["../../src/utils.ts","../../src/typeGuards.ts","../../src/sanitization.ts","../../src/anthropic/index.ts"],"sourcesContent":["import { PostHog } from 'posthog-node'\nimport { Buffer } from 'buffer'\nimport OpenAIOrignal from 'openai'\nimport AnthropicOriginal from '@anthropic-ai/sdk'\nimport type { ChatCompletionTool } from 'openai/resources/chat/completions'\nimport type { ResponseCreateParamsWithTools } from 'openai/lib/ResponsesParser'\nimport type { Tool as GeminiTool } from '@google/genai'\nimport type { FormattedMessage, FormattedContent, TokenUsage } from './types'\nimport { version } from '../package.json'\nimport { v4 as uuidv4 } from 'uuid'\n\ntype ChatCompletionCreateParamsBase = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams\ntype MessageCreateParams = AnthropicOriginal.Messages.MessageCreateParams\ntype ResponseCreateParams = OpenAIOrignal.Responses.ResponseCreateParams\ntype EmbeddingCreateParams = OpenAIOrignal.EmbeddingCreateParams\ntype AnthropicTool = AnthropicOriginal.Tool\n\n// limit large outputs by truncating to 200kb (approx 200k bytes)\nexport const MAX_OUTPUT_SIZE = 200000\nconst STRING_FORMAT = 'utf8'\n\nexport interface MonitoringEventPropertiesWithDefaults {\n  distinctId?: string\n  traceId: string\n  properties?: Record<string, any>\n  privacyMode: boolean\n  groups?: Record<string, any>\n  modelOverride?: string\n  providerOverride?: string\n  costOverride?: CostOverride\n  captureImmediate?: boolean\n}\n\nexport type MonitoringEventProperties = Partial<MonitoringEventPropertiesWithDefaults>\n\nexport type MonitoringParams = {\n  [K in keyof MonitoringEventProperties as `posthog${Capitalize<string & K>}`]: MonitoringEventProperties[K]\n}\n\nexport interface CostOverride {\n  inputCost: number\n  outputCost: number\n}\n\nexport const getModelParams = (\n  params:\n    | ((\n        | ChatCompletionCreateParamsBase\n        | MessageCreateParams\n        | ResponseCreateParams\n        | ResponseCreateParamsWithTools\n        | EmbeddingCreateParams\n      ) &\n        MonitoringParams)\n    | null\n): Record<string, any> => {\n  if (!params) {\n    return {}\n  }\n  const modelParams: Record<string, any> = {}\n  const paramKeys = [\n    'temperature',\n    'max_tokens',\n    'max_completion_tokens',\n    'top_p',\n    'frequency_penalty',\n    'presence_penalty',\n    'n',\n    'stop',\n    'stream',\n    'streaming',\n  ] as const\n\n  for (const key of paramKeys) {\n    if (key in params && (params as any)[key] !== undefined) {\n      modelParams[key] = (params as any)[key]\n    }\n  }\n  return modelParams\n}\n\n/**\n * Helper to format responses (non-streaming) for consumption, mirroring Python's openai vs. anthropic approach.\n */\nexport const formatResponse = (response: any, provider: string): FormattedMessage[] => {\n  if (!response) {\n    return []\n  }\n  if (provider === 'anthropic') {\n    return formatResponseAnthropic(response)\n  } else if (provider === 'openai') {\n    return formatResponseOpenAI(response)\n  } else if (provider === 'gemini') {\n    return formatResponseGemini(response)\n  }\n  return []\n}\n\nexport const formatResponseAnthropic = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n  const content: FormattedContent = []\n\n  for (const choice of response.content ?? []) {\n    if (choice?.type === 'text' && choice?.text) {\n      content.push({ type: 'text', text: choice.text })\n    } else if (choice?.type === 'tool_use' && choice?.name && choice?.id) {\n      content.push({\n        type: 'function',\n        id: choice.id,\n        function: {\n          name: choice.name,\n          arguments: choice.input || {},\n        },\n      })\n    }\n  }\n\n  if (content.length > 0) {\n    output.push({\n      role: 'assistant',\n      content,\n    })\n  }\n\n  return output\n}\n\nexport const formatResponseOpenAI = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.choices) {\n    for (const choice of response.choices) {\n      const content: FormattedContent = []\n      let role = 'assistant'\n\n      if (choice.message) {\n        if (choice.message.role) {\n          role = choice.message.role\n        }\n\n        if (choice.message.content) {\n          content.push({ type: 'text', text: choice.message.content })\n        }\n\n        if (choice.message.tool_calls) {\n          for (const toolCall of choice.message.tool_calls) {\n            content.push({\n              type: 'function',\n              id: toolCall.id,\n              function: {\n                name: toolCall.function.name,\n                arguments: toolCall.function.arguments,\n              },\n            })\n          }\n        }\n      }\n\n      if (content.length > 0) {\n        output.push({\n          role,\n          content,\n        })\n      }\n    }\n  }\n\n  // Handle Responses API format\n  if (response.output) {\n    const content: FormattedContent = []\n    let role = 'assistant'\n\n    for (const item of response.output) {\n      if (item.type === 'message') {\n        role = item.role\n\n        if (item.content && Array.isArray(item.content)) {\n          for (const contentItem of item.content) {\n            if (contentItem.type === 'output_text' && contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.type === 'input_image' && contentItem.image_url) {\n              content.push({\n                type: 'image',\n                image: contentItem.image_url,\n              })\n            }\n          }\n        } else if (item.content) {\n          content.push({ type: 'text', text: String(item.content) })\n        }\n      } else if (item.type === 'function_call') {\n        content.push({\n          type: 'function',\n          id: item.call_id || item.id || '',\n          function: {\n            name: item.name,\n            arguments: item.arguments || {},\n          },\n        })\n      }\n    }\n\n    if (content.length > 0) {\n      output.push({\n        role,\n        content,\n      })\n    }\n  }\n\n  return output\n}\n\nexport const formatResponseGemini = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.candidates && Array.isArray(response.candidates)) {\n    for (const candidate of response.candidates) {\n      if (candidate.content && candidate.content.parts) {\n        const content: FormattedContent = []\n\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            content.push({ type: 'text', text: part.text })\n          } else if (part.functionCall) {\n            content.push({\n              type: 'function',\n              function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args,\n              },\n            })\n          }\n        }\n\n        if (content.length > 0) {\n          output.push({\n            role: 'assistant',\n            content,\n          })\n        }\n      } else if (candidate.text) {\n        output.push({\n          role: 'assistant',\n          content: [{ type: 'text', text: candidate.text }],\n        })\n      }\n    }\n  } else if (response.text) {\n    output.push({\n      role: 'assistant',\n      content: [{ type: 'text', text: response.text }],\n    })\n  }\n\n  return output\n}\n\nexport const mergeSystemPrompt = (params: MessageCreateParams & MonitoringParams, provider: string): any => {\n  if (provider == 'anthropic') {\n    const messages = params.messages || []\n    if (!(params as any).system) {\n      return messages\n    }\n    const systemMessage = (params as any).system\n    return [{ role: 'system', content: systemMessage }, ...messages]\n  }\n  return params.messages\n}\n\nexport const withPrivacyMode = (client: PostHog, privacyMode: boolean, input: any): any => {\n  return (client as any).privacy_mode || privacyMode ? null : input\n}\n\nfunction toSafeString(input: unknown): string {\n  if (input === undefined || input === null) {\n    return ''\n  }\n  if (typeof input === 'string') {\n    return input\n  }\n  try {\n    return JSON.stringify(input)\n  } catch {\n    console.warn('Failed to stringify input', input)\n    return ''\n  }\n}\n\nexport const truncate = (input: unknown): string => {\n  const str = toSafeString(input)\n  if (str === '') {\n    return ''\n  }\n\n  // Check if we need to truncate and ensure STRING_FORMAT is respected\n  const encoder = new TextEncoder()\n  const buffer = encoder.encode(str)\n  if (buffer.length <= MAX_OUTPUT_SIZE) {\n    // Ensure STRING_FORMAT is respected\n    return new TextDecoder(STRING_FORMAT).decode(buffer)\n  }\n\n  // Truncate the buffer and ensure a valid string is returned\n  const truncatedBuffer = buffer.slice(0, MAX_OUTPUT_SIZE)\n  // fatal: false means we get U+FFFD at the end if truncation broke the encoding\n  const decoder = new TextDecoder(STRING_FORMAT, { fatal: false })\n  let truncatedStr = decoder.decode(truncatedBuffer)\n  if (truncatedStr.endsWith('\\uFFFD')) {\n    truncatedStr = truncatedStr.slice(0, -1)\n  }\n  return `${truncatedStr}... [truncated]`\n}\n\n/**\n * Extract available tool calls from the request parameters.\n * These are the tools provided to the LLM, not the tool calls in the response.\n */\nexport const extractAvailableToolCalls = (\n  provider: string,\n  params: any\n): ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null => {\n  if (provider === 'anthropic') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'gemini') {\n    if (params.config && params.config.tools) {\n      return params.config.tools\n    }\n\n    return null\n  } else if (provider === 'openai') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'vercel') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  }\n\n  return null\n}\n\nexport enum AIEvent {\n  Generation = '$ai_generation',\n  Embedding = '$ai_embedding',\n}\n\nexport type SendEventToPosthogParams = {\n  client: PostHog\n  eventType?: AIEvent\n  distinctId?: string\n  traceId: string\n  model: string\n  provider: string\n  input: any\n  output: any\n  latency: number\n  baseURL: string\n  httpStatus: number\n  usage?: TokenUsage\n  params: (\n    | ChatCompletionCreateParamsBase\n    | MessageCreateParams\n    | ResponseCreateParams\n    | ResponseCreateParamsWithTools\n    | EmbeddingCreateParams\n  ) &\n    MonitoringParams\n  isError?: boolean\n  error?: string\n  tools?: ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null\n  captureImmediate?: boolean\n}\n\nfunction sanitizeValues(obj: any): any {\n  if (obj === undefined || obj === null) {\n    return obj\n  }\n  const jsonSafe = JSON.parse(JSON.stringify(obj))\n  if (typeof jsonSafe === 'string') {\n    return Buffer.from(jsonSafe, STRING_FORMAT).toString(STRING_FORMAT)\n  } else if (Array.isArray(jsonSafe)) {\n    return jsonSafe.map(sanitizeValues)\n  } else if (jsonSafe && typeof jsonSafe === 'object') {\n    return Object.fromEntries(Object.entries(jsonSafe).map(([k, v]) => [k, sanitizeValues(v)]))\n  }\n  return jsonSafe\n}\n\nconst POSTHOG_PARAMS_MAP: Record<keyof MonitoringParams, string> = {\n  posthogDistinctId: 'distinctId',\n  posthogTraceId: 'traceId',\n  posthogProperties: 'properties',\n  posthogPrivacyMode: 'privacyMode',\n  posthogGroups: 'groups',\n  posthogModelOverride: 'modelOverride',\n  posthogProviderOverride: 'providerOverride',\n  posthogCostOverride: 'costOverride',\n  posthogCaptureImmediate: 'captureImmediate',\n}\n\nexport function extractPosthogParams<T>(body: T & MonitoringParams): {\n  providerParams: T\n  posthogParams: MonitoringEventPropertiesWithDefaults\n} {\n  const providerParams: Record<string, unknown> = {}\n  const posthogParams: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(body)) {\n    if (POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]) {\n      posthogParams[POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]] = value\n    } else if (key.startsWith('posthog')) {\n      console.warn(`Unknown Posthog parameter ${key}`)\n    } else {\n      providerParams[key] = value\n    }\n  }\n\n  return {\n    providerParams: providerParams as T,\n    posthogParams: addDefaults(posthogParams),\n  }\n}\n\nfunction addDefaults(params: MonitoringEventProperties): MonitoringEventPropertiesWithDefaults {\n  return {\n    ...params,\n    privacyMode: params.privacyMode ?? false,\n    traceId: params.traceId ?? uuidv4(),\n  }\n}\n\nexport const sendEventToPosthog = async ({\n  client,\n  eventType = AIEvent.Generation,\n  distinctId,\n  traceId,\n  model,\n  provider,\n  input,\n  output,\n  latency,\n  baseURL,\n  params,\n  httpStatus = 200,\n  usage = {},\n  isError = false,\n  error,\n  tools,\n  captureImmediate = false,\n}: SendEventToPosthogParams): Promise<void> => {\n  if (!client.capture) {\n    return Promise.resolve()\n  }\n  // sanitize input and output for UTF-8 validity\n  const safeInput = sanitizeValues(input)\n  const safeOutput = sanitizeValues(output)\n  const safeError = sanitizeValues(error)\n\n  let errorData = {}\n  if (isError) {\n    errorData = {\n      $ai_is_error: true,\n      $ai_error: safeError,\n    }\n  }\n  let costOverrideData = {}\n  if (params.posthogCostOverride) {\n    const inputCostUSD = (params.posthogCostOverride.inputCost ?? 0) * (usage.inputTokens ?? 0)\n    const outputCostUSD = (params.posthogCostOverride.outputCost ?? 0) * (usage.outputTokens ?? 0)\n    costOverrideData = {\n      $ai_input_cost_usd: inputCostUSD,\n      $ai_output_cost_usd: outputCostUSD,\n      $ai_total_cost_usd: inputCostUSD + outputCostUSD,\n    }\n  }\n\n  const additionalTokenValues = {\n    ...(usage.reasoningTokens ? { $ai_reasoning_tokens: usage.reasoningTokens } : {}),\n    ...(usage.cacheReadInputTokens ? { $ai_cache_read_input_tokens: usage.cacheReadInputTokens } : {}),\n    ...(usage.cacheCreationInputTokens ? { $ai_cache_creation_input_tokens: usage.cacheCreationInputTokens } : {}),\n  }\n\n  const properties = {\n    $ai_lib: 'posthog-ai',\n    $ai_lib_version: version,\n    $ai_provider: params.posthogProviderOverride ?? provider,\n    $ai_model: params.posthogModelOverride ?? model,\n    $ai_model_parameters: getModelParams(params),\n    $ai_input: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeInput),\n    $ai_output_choices: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeOutput),\n    $ai_http_status: httpStatus,\n    $ai_input_tokens: usage.inputTokens ?? 0,\n    ...(usage.outputTokens !== undefined ? { $ai_output_tokens: usage.outputTokens } : {}),\n    ...additionalTokenValues,\n    $ai_latency: latency,\n    $ai_trace_id: traceId,\n    $ai_base_url: baseURL,\n    ...params.posthogProperties,\n    ...(distinctId ? {} : { $process_person_profile: false }),\n    ...(tools ? { $ai_tools: tools } : {}),\n    ...errorData,\n    ...costOverrideData,\n  }\n\n  const event = {\n    distinctId: distinctId ?? traceId,\n    event: eventType,\n    properties,\n    groups: params.posthogGroups,\n  }\n\n  if (captureImmediate) {\n    // await capture promise to send single event in serverless environments\n    await client.captureImmediate(event)\n  } else {\n    client.capture(event)\n  }\n}\n","// Type guards for safer type checking\n\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string'\n}\n\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isString, isObject } from './typeGuards'\n\nconst REDACTED_IMAGE_PLACEHOLDER = '[base64 image redacted]'\n\n// ============================================\n// Base64 Detection Helpers\n// ============================================\n\nconst isBase64DataUrl = (str: string): boolean => {\n  return /^data:([^;]+);base64,/.test(str)\n}\n\nconst isValidUrl = (str: string): boolean => {\n  try {\n    new URL(str)\n    return true\n  } catch {\n    // Not an absolute URL, check if it's a relative URL or path\n    return str.startsWith('/') || str.startsWith('./') || str.startsWith('../')\n  }\n}\n\nconst isRawBase64 = (str: string): boolean => {\n  // Skip if it's a valid URL or path\n  if (isValidUrl(str)) {\n    return false\n  }\n\n  // Check if it's a valid base64 string\n  // Base64 images are typically at least a few hundred chars, but we'll be conservative\n  return str.length > 20 && /^[A-Za-z0-9+/]+=*$/.test(str)\n}\n\nexport function redactBase64DataUrl(str: string): string\nexport function redactBase64DataUrl(str: unknown): unknown\nexport function redactBase64DataUrl(str: unknown): unknown {\n  if (!isString(str)) return str\n\n  // Check for data URL format\n  if (isBase64DataUrl(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  // Check for raw base64 (Vercel sends raw base64 for inline images)\n  if (isRawBase64(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  return str\n}\n\n// ============================================\n// Common Message Processing\n// ============================================\n\ntype ContentTransformer = (item: unknown) => unknown\n\nconst processMessages = (messages: unknown, transformContent: ContentTransformer): unknown => {\n  if (!messages) return messages\n\n  const processContent = (content: unknown): unknown => {\n    if (typeof content === 'string') return content\n\n    if (!content) return content\n\n    if (Array.isArray(content)) {\n      return content.map(transformContent)\n    }\n\n    // Handle single object content\n    return transformContent(content)\n  }\n\n  const processMessage = (msg: unknown): unknown => {\n    if (!isObject(msg) || !('content' in msg)) return msg\n    return { ...msg, content: processContent(msg.content) }\n  }\n\n  // Handle both arrays and single messages\n  if (Array.isArray(messages)) {\n    return messages.map(processMessage)\n  }\n\n  return processMessage(messages)\n}\n\n// ============================================\n// Provider-Specific Image Sanitizers\n// ============================================\n\nconst sanitizeOpenAIImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle image_url format\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeOpenAIResponseImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle input_image format\n  if (item.type === 'input_image' && 'image_url' in item) {\n    return {\n      ...item,\n      image_url: redactBase64DataUrl(item.image_url),\n    }\n  }\n\n  return item\n}\n\nconst sanitizeAnthropicImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle Anthropic's image format\n  if (\n    item.type === 'image' &&\n    'source' in item &&\n    isObject(item.source) &&\n    item.source.type === 'base64' &&\n    'data' in item.source\n  ) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeGeminiPart = (part: unknown): unknown => {\n  if (!isObject(part)) return part\n\n  // Handle Gemini's inline data format\n  if ('inlineData' in part && isObject(part.inlineData) && 'data' in part.inlineData) {\n    return {\n      ...part,\n      inlineData: {\n        ...part.inlineData,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return part\n}\n\nconst processGeminiItem = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // If it has parts, process them\n  if ('parts' in item && item.parts) {\n    const parts = Array.isArray(item.parts) ? item.parts.map(sanitizeGeminiPart) : sanitizeGeminiPart(item.parts)\n\n    return { ...item, parts }\n  }\n\n  return item\n}\n\nconst sanitizeLangChainImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // OpenAI style\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  // Direct image with data field\n  if (item.type === 'image' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  // Anthropic style\n  if (item.type === 'image' && 'source' in item && isObject(item.source) && 'data' in item.source) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: redactBase64DataUrl(item.source.data),\n      },\n    }\n  }\n\n  // Google style\n  if (item.type === 'media' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  return item\n}\n\n// Export individual sanitizers for tree-shaking\nexport const sanitizeOpenAI = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIImage)\n}\n\nexport const sanitizeOpenAIResponse = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIResponseImage)\n}\n\nexport const sanitizeAnthropic = (data: unknown): unknown => {\n  return processMessages(data, sanitizeAnthropicImage)\n}\n\nexport const sanitizeGemini = (data: unknown): unknown => {\n  // Gemini has a different structure with 'parts' directly on items instead of 'content'\n  // So we need custom processing instead of using processMessages\n  if (!data) return data\n\n  if (Array.isArray(data)) {\n    return data.map(processGeminiItem)\n  }\n\n  return processGeminiItem(data)\n}\n\nexport const sanitizeLangChain = (data: unknown): unknown => {\n  return processMessages(data, sanitizeLangChainImage)\n}\n","import AnthropicOriginal, { APIPromise } from '@anthropic-ai/sdk'\nimport { PostHog } from 'posthog-node'\nimport {\n  formatResponseAnthropic,\n  mergeSystemPrompt,\n  MonitoringParams,\n  sendEventToPosthog,\n  extractAvailableToolCalls,\n  extractPosthogParams,\n} from '../utils'\nimport type { FormattedContentItem, FormattedTextContent, FormattedFunctionCall, FormattedMessage } from '../types'\n\ntype MessageCreateParamsNonStreaming = AnthropicOriginal.Messages.MessageCreateParamsNonStreaming\ntype MessageCreateParamsStreaming = AnthropicOriginal.Messages.MessageCreateParamsStreaming\ntype MessageCreateParams = AnthropicOriginal.Messages.MessageCreateParams\ntype Message = AnthropicOriginal.Messages.Message\ntype RawMessageStreamEvent = AnthropicOriginal.Messages.RawMessageStreamEvent\ntype MessageCreateParamsBase = AnthropicOriginal.Messages.MessageCreateParams\ntype RequestOptions = AnthropicOriginal.RequestOptions\nimport type { Stream } from '@anthropic-ai/sdk/streaming'\nimport { sanitizeAnthropic } from '../sanitization'\n\ninterface ToolInProgress {\n  block: FormattedFunctionCall\n  inputString: string\n}\n\ninterface MonitoringAnthropicConfig {\n  apiKey: string\n  posthog: PostHog\n  baseURL?: string\n}\n\nexport class PostHogAnthropic extends AnthropicOriginal {\n  private readonly phClient: PostHog\n  public messages: WrappedMessages\n\n  constructor(config: MonitoringAnthropicConfig) {\n    const { posthog, ...anthropicConfig } = config\n    super(anthropicConfig)\n    this.phClient = posthog\n    this.messages = new WrappedMessages(this, this.phClient)\n  }\n}\n\nexport class WrappedMessages extends AnthropicOriginal.Messages {\n  private readonly phClient: PostHog\n  private readonly baseURL: string\n\n  constructor(parentClient: PostHogAnthropic, phClient: PostHog) {\n    super(parentClient)\n    this.phClient = phClient\n    this.baseURL = parentClient.baseURL\n  }\n\n  public create(body: MessageCreateParamsNonStreaming, options?: RequestOptions): APIPromise<Message>\n  public create(\n    body: MessageCreateParamsStreaming & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<Stream<RawMessageStreamEvent>>\n  public create(\n    body: MessageCreateParamsBase & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<Stream<RawMessageStreamEvent> | Message>\n  public create(\n    body: MessageCreateParams & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<Message> | APIPromise<Stream<RawMessageStreamEvent>> {\n    const { providerParams: anthropicParams, posthogParams } = extractPosthogParams(body)\n    const startTime = Date.now()\n\n    const parentPromise = super.create(anthropicParams, options)\n\n    if (anthropicParams.stream) {\n      return parentPromise.then((value) => {\n        let accumulatedContent = ''\n        const contentBlocks: FormattedContentItem[] = []\n        const toolsInProgress: Map<string, ToolInProgress> = new Map()\n        let currentTextBlock: FormattedTextContent | null = null\n\n        const usage: {\n          inputTokens: number\n          outputTokens: number\n          cacheCreationInputTokens?: number\n          cacheReadInputTokens?: number\n        } = {\n          inputTokens: 0,\n          outputTokens: 0,\n          cacheCreationInputTokens: 0,\n          cacheReadInputTokens: 0,\n        }\n        if ('tee' in value) {\n          const [stream1, stream2] = value.tee()\n          ;(async () => {\n            try {\n              for await (const chunk of stream1) {\n                // Handle content block start events\n                if (chunk.type === 'content_block_start') {\n                  if (chunk.content_block?.type === 'text') {\n                    currentTextBlock = {\n                      type: 'text',\n                      text: '',\n                    }\n\n                    contentBlocks.push(currentTextBlock)\n                  } else if (chunk.content_block?.type === 'tool_use') {\n                    const toolBlock: FormattedFunctionCall = {\n                      type: 'function',\n                      id: chunk.content_block.id,\n                      function: {\n                        name: chunk.content_block.name,\n                        arguments: {},\n                      },\n                    }\n\n                    contentBlocks.push(toolBlock)\n\n                    toolsInProgress.set(chunk.content_block.id, {\n                      block: toolBlock,\n                      inputString: '',\n                    })\n\n                    currentTextBlock = null\n                  }\n                }\n\n                // Handle text delta events\n                if ('delta' in chunk) {\n                  if ('text' in chunk.delta) {\n                    const delta = chunk.delta.text\n\n                    accumulatedContent += delta\n\n                    if (currentTextBlock) {\n                      currentTextBlock.text += delta\n                    }\n                  }\n                }\n\n                // Handle tool input delta events\n                if (chunk.type === 'content_block_delta' && chunk.delta?.type === 'input_json_delta') {\n                  const block = chunk.index !== undefined ? contentBlocks[chunk.index] : undefined\n                  const toolId = block?.type === 'function' ? block.id : undefined\n\n                  if (toolId && toolsInProgress.has(toolId)) {\n                    const tool = toolsInProgress.get(toolId)\n                    if (tool) {\n                      tool.inputString += chunk.delta.partial_json || ''\n                    }\n                  }\n                }\n\n                // Handle content block stop events\n                if (chunk.type === 'content_block_stop') {\n                  currentTextBlock = null\n\n                  // Parse accumulated tool input\n                  if (chunk.index !== undefined) {\n                    const block = contentBlocks[chunk.index]\n\n                    if (block?.type === 'function' && block.id && toolsInProgress.has(block.id)) {\n                      const tool = toolsInProgress.get(block.id)\n                      if (tool) {\n                        try {\n                          block.function.arguments = JSON.parse(tool.inputString)\n                        } catch (e) {\n                          // Keep empty object if parsing fails\n                          console.error('Error parsing tool input:', e)\n                        }\n                      }\n                      toolsInProgress.delete(block.id)\n                    }\n                  }\n                }\n\n                if (chunk.type == 'message_start') {\n                  usage.inputTokens = chunk.message.usage.input_tokens ?? 0\n                  usage.cacheCreationInputTokens = chunk.message.usage.cache_creation_input_tokens ?? 0\n                  usage.cacheReadInputTokens = chunk.message.usage.cache_read_input_tokens ?? 0\n                }\n                if ('usage' in chunk) {\n                  usage.outputTokens = chunk.usage.output_tokens ?? 0\n                }\n              }\n\n              const latency = (Date.now() - startTime) / 1000\n\n              const availableTools = extractAvailableToolCalls('anthropic', anthropicParams)\n\n              // Format output to match non-streaming version\n              const formattedOutput: FormattedMessage[] =\n                contentBlocks.length > 0\n                  ? [\n                      {\n                        role: 'assistant',\n                        content: contentBlocks,\n                      },\n                    ]\n                  : [\n                      {\n                        role: 'assistant',\n                        content: [{ type: 'text', text: accumulatedContent }],\n                      },\n                    ]\n\n              await sendEventToPosthog({\n                client: this.phClient,\n                ...posthogParams,\n                model: anthropicParams.model,\n                provider: 'anthropic',\n                input: sanitizeAnthropic(mergeSystemPrompt(anthropicParams, 'anthropic')),\n                output: formattedOutput,\n                latency,\n                baseURL: this.baseURL,\n                params: body,\n                httpStatus: 200,\n                usage,\n                tools: availableTools,\n              })\n            } catch (error: any) {\n              // error handling\n              await sendEventToPosthog({\n                client: this.phClient,\n                ...posthogParams,\n                model: anthropicParams.model,\n                provider: 'anthropic',\n                input: sanitizeAnthropic(mergeSystemPrompt(anthropicParams, 'anthropic')),\n                output: [],\n                latency: 0,\n                baseURL: this.baseURL,\n                params: body,\n                httpStatus: error?.status ? error.status : 500,\n                usage: {\n                  inputTokens: 0,\n                  outputTokens: 0,\n                },\n                isError: true,\n                error: JSON.stringify(error),\n              })\n            }\n          })()\n\n          // Return the other stream to the user\n          return stream2\n        }\n        return value\n      }) as APIPromise<Stream<RawMessageStreamEvent>>\n    } else {\n      const wrappedPromise = parentPromise.then(\n        async (result) => {\n          if ('content' in result) {\n            const latency = (Date.now() - startTime) / 1000\n\n            const availableTools = extractAvailableToolCalls('anthropic', anthropicParams)\n\n            await sendEventToPosthog({\n              client: this.phClient,\n              ...posthogParams,\n              model: anthropicParams.model,\n              provider: 'anthropic',\n              input: sanitizeAnthropic(mergeSystemPrompt(anthropicParams, 'anthropic')),\n              output: formatResponseAnthropic(result),\n              latency,\n              baseURL: this.baseURL,\n              params: body,\n              httpStatus: 200,\n              usage: {\n                inputTokens: result.usage.input_tokens ?? 0,\n                outputTokens: result.usage.output_tokens ?? 0,\n                cacheCreationInputTokens: result.usage.cache_creation_input_tokens ?? 0,\n                cacheReadInputTokens: result.usage.cache_read_input_tokens ?? 0,\n              },\n              tools: availableTools,\n            })\n          }\n          return result\n        },\n        async (error: any) => {\n          await sendEventToPosthog({\n            client: this.phClient,\n            ...posthogParams,\n            model: anthropicParams.model,\n            provider: 'anthropic',\n            input: sanitizeAnthropic(mergeSystemPrompt(anthropicParams, 'anthropic')),\n            output: [],\n            latency: 0,\n            baseURL: this.baseURL,\n            params: body,\n            httpStatus: error?.status ? error.status : 500,\n            usage: {\n              inputTokens: 0,\n              outputTokens: 0,\n            },\n            isError: true,\n            error: JSON.stringify(error),\n          })\n          throw error\n        }\n      ) as APIPromise<Message>\n\n      return wrappedPromise\n    }\n  }\n}\n\nexport default PostHogAnthropic\n\nexport { PostHogAnthropic as Anthropic }\n"],"names":["STRING_FORMAT","getModelParams","params","modelParams","paramKeys","key","undefined","formatResponseAnthropic","response","output","content","choice","type","text","push","name","id","function","arguments","input","length","role","mergeSystemPrompt","provider","messages","system","systemMessage","withPrivacyMode","client","privacyMode","privacy_mode","extractAvailableToolCalls","tools","AIEvent","sanitizeValues","obj","jsonSafe","JSON","parse","stringify","Buffer","from","toString","Array","isArray","map","Object","fromEntries","entries","k","v","POSTHOG_PARAMS_MAP","posthogDistinctId","posthogTraceId","posthogProperties","posthogPrivacyMode","posthogGroups","posthogModelOverride","posthogProviderOverride","posthogCostOverride","posthogCaptureImmediate","extractPosthogParams","body","providerParams","posthogParams","value","startsWith","console","warn","addDefaults","traceId","uuidv4","sendEventToPosthog","eventType","Generation","distinctId","model","latency","baseURL","httpStatus","usage","isError","error","captureImmediate","capture","Promise","resolve","safeInput","safeOutput","safeError","errorData","$ai_is_error","$ai_error","costOverrideData","inputCostUSD","inputCost","inputTokens","outputCostUSD","outputCost","outputTokens","$ai_input_cost_usd","$ai_output_cost_usd","$ai_total_cost_usd","additionalTokenValues","reasoningTokens","$ai_reasoning_tokens","cacheReadInputTokens","$ai_cache_read_input_tokens","cacheCreationInputTokens","$ai_cache_creation_input_tokens","properties","$ai_lib","$ai_lib_version","version","$ai_provider","$ai_model","$ai_model_parameters","$ai_input","$ai_output_choices","$ai_http_status","$ai_input_tokens","$ai_output_tokens","$ai_latency","$ai_trace_id","$ai_base_url","$process_person_profile","$ai_tools","event","groups","isObject","REDACTED_IMAGE_PLACEHOLDER","processMessages","transformContent","processContent","processMessage","msg","sanitizeAnthropicImage","item","source","data","sanitizeAnthropic","PostHogAnthropic","AnthropicOriginal","constructor","config","posthog","anthropicConfig","phClient","WrappedMessages","Messages","parentClient","create","options","anthropicParams","startTime","Date","now","parentPromise","stream","then","accumulatedContent","contentBlocks","toolsInProgress","Map","currentTextBlock","stream1","stream2","tee","chunk","content_block","toolBlock","set","block","inputString","delta","index","toolId","has","tool","get","partial_json","e","delete","message","input_tokens","cache_creation_input_tokens","cache_read_input_tokens","output_tokens","availableTools","formattedOutput","status","wrappedPromise","result"],"mappings":"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"}