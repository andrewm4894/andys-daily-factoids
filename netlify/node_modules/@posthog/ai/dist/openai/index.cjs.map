{"version":3,"file":"index.cjs","sources":["../../src/utils.ts","../../src/typeGuards.ts","../../src/sanitization.ts","../../src/openai/index.ts"],"sourcesContent":["import { PostHog } from 'posthog-node'\nimport { Buffer } from 'buffer'\nimport OpenAIOrignal from 'openai'\nimport AnthropicOriginal from '@anthropic-ai/sdk'\nimport type { ChatCompletionTool } from 'openai/resources/chat/completions'\nimport type { ResponseCreateParamsWithTools } from 'openai/lib/ResponsesParser'\nimport type { Tool as GeminiTool } from '@google/genai'\nimport type { FormattedMessage, FormattedContent, TokenUsage } from './types'\nimport { version } from '../package.json'\nimport { v4 as uuidv4 } from 'uuid'\n\ntype ChatCompletionCreateParamsBase = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams\ntype MessageCreateParams = AnthropicOriginal.Messages.MessageCreateParams\ntype ResponseCreateParams = OpenAIOrignal.Responses.ResponseCreateParams\ntype EmbeddingCreateParams = OpenAIOrignal.EmbeddingCreateParams\ntype AnthropicTool = AnthropicOriginal.Tool\n\n// limit large outputs by truncating to 200kb (approx 200k bytes)\nexport const MAX_OUTPUT_SIZE = 200000\nconst STRING_FORMAT = 'utf8'\n\nexport interface MonitoringEventPropertiesWithDefaults {\n  distinctId?: string\n  traceId: string\n  properties?: Record<string, any>\n  privacyMode: boolean\n  groups?: Record<string, any>\n  modelOverride?: string\n  providerOverride?: string\n  costOverride?: CostOverride\n  captureImmediate?: boolean\n}\n\nexport type MonitoringEventProperties = Partial<MonitoringEventPropertiesWithDefaults>\n\nexport type MonitoringParams = {\n  [K in keyof MonitoringEventProperties as `posthog${Capitalize<string & K>}`]: MonitoringEventProperties[K]\n}\n\nexport interface CostOverride {\n  inputCost: number\n  outputCost: number\n}\n\nexport const getModelParams = (\n  params:\n    | ((\n        | ChatCompletionCreateParamsBase\n        | MessageCreateParams\n        | ResponseCreateParams\n        | ResponseCreateParamsWithTools\n        | EmbeddingCreateParams\n      ) &\n        MonitoringParams)\n    | null\n): Record<string, any> => {\n  if (!params) {\n    return {}\n  }\n  const modelParams: Record<string, any> = {}\n  const paramKeys = [\n    'temperature',\n    'max_tokens',\n    'max_completion_tokens',\n    'top_p',\n    'frequency_penalty',\n    'presence_penalty',\n    'n',\n    'stop',\n    'stream',\n    'streaming',\n  ] as const\n\n  for (const key of paramKeys) {\n    if (key in params && (params as any)[key] !== undefined) {\n      modelParams[key] = (params as any)[key]\n    }\n  }\n  return modelParams\n}\n\n/**\n * Helper to format responses (non-streaming) for consumption, mirroring Python's openai vs. anthropic approach.\n */\nexport const formatResponse = (response: any, provider: string): FormattedMessage[] => {\n  if (!response) {\n    return []\n  }\n  if (provider === 'anthropic') {\n    return formatResponseAnthropic(response)\n  } else if (provider === 'openai') {\n    return formatResponseOpenAI(response)\n  } else if (provider === 'gemini') {\n    return formatResponseGemini(response)\n  }\n  return []\n}\n\nexport const formatResponseAnthropic = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n  const content: FormattedContent = []\n\n  for (const choice of response.content ?? []) {\n    if (choice?.type === 'text' && choice?.text) {\n      content.push({ type: 'text', text: choice.text })\n    } else if (choice?.type === 'tool_use' && choice?.name && choice?.id) {\n      content.push({\n        type: 'function',\n        id: choice.id,\n        function: {\n          name: choice.name,\n          arguments: choice.input || {},\n        },\n      })\n    }\n  }\n\n  if (content.length > 0) {\n    output.push({\n      role: 'assistant',\n      content,\n    })\n  }\n\n  return output\n}\n\nexport const formatResponseOpenAI = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.choices) {\n    for (const choice of response.choices) {\n      const content: FormattedContent = []\n      let role = 'assistant'\n\n      if (choice.message) {\n        if (choice.message.role) {\n          role = choice.message.role\n        }\n\n        if (choice.message.content) {\n          content.push({ type: 'text', text: choice.message.content })\n        }\n\n        if (choice.message.tool_calls) {\n          for (const toolCall of choice.message.tool_calls) {\n            content.push({\n              type: 'function',\n              id: toolCall.id,\n              function: {\n                name: toolCall.function.name,\n                arguments: toolCall.function.arguments,\n              },\n            })\n          }\n        }\n      }\n\n      if (content.length > 0) {\n        output.push({\n          role,\n          content,\n        })\n      }\n    }\n  }\n\n  // Handle Responses API format\n  if (response.output) {\n    const content: FormattedContent = []\n    let role = 'assistant'\n\n    for (const item of response.output) {\n      if (item.type === 'message') {\n        role = item.role\n\n        if (item.content && Array.isArray(item.content)) {\n          for (const contentItem of item.content) {\n            if (contentItem.type === 'output_text' && contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.type === 'input_image' && contentItem.image_url) {\n              content.push({\n                type: 'image',\n                image: contentItem.image_url,\n              })\n            }\n          }\n        } else if (item.content) {\n          content.push({ type: 'text', text: String(item.content) })\n        }\n      } else if (item.type === 'function_call') {\n        content.push({\n          type: 'function',\n          id: item.call_id || item.id || '',\n          function: {\n            name: item.name,\n            arguments: item.arguments || {},\n          },\n        })\n      }\n    }\n\n    if (content.length > 0) {\n      output.push({\n        role,\n        content,\n      })\n    }\n  }\n\n  return output\n}\n\nexport const formatResponseGemini = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.candidates && Array.isArray(response.candidates)) {\n    for (const candidate of response.candidates) {\n      if (candidate.content && candidate.content.parts) {\n        const content: FormattedContent = []\n\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            content.push({ type: 'text', text: part.text })\n          } else if (part.functionCall) {\n            content.push({\n              type: 'function',\n              function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args,\n              },\n            })\n          }\n        }\n\n        if (content.length > 0) {\n          output.push({\n            role: 'assistant',\n            content,\n          })\n        }\n      } else if (candidate.text) {\n        output.push({\n          role: 'assistant',\n          content: [{ type: 'text', text: candidate.text }],\n        })\n      }\n    }\n  } else if (response.text) {\n    output.push({\n      role: 'assistant',\n      content: [{ type: 'text', text: response.text }],\n    })\n  }\n\n  return output\n}\n\nexport const mergeSystemPrompt = (params: MessageCreateParams & MonitoringParams, provider: string): any => {\n  if (provider == 'anthropic') {\n    const messages = params.messages || []\n    if (!(params as any).system) {\n      return messages\n    }\n    const systemMessage = (params as any).system\n    return [{ role: 'system', content: systemMessage }, ...messages]\n  }\n  return params.messages\n}\n\nexport const withPrivacyMode = (client: PostHog, privacyMode: boolean, input: any): any => {\n  return (client as any).privacy_mode || privacyMode ? null : input\n}\n\nfunction toSafeString(input: unknown): string {\n  if (input === undefined || input === null) {\n    return ''\n  }\n  if (typeof input === 'string') {\n    return input\n  }\n  try {\n    return JSON.stringify(input)\n  } catch {\n    console.warn('Failed to stringify input', input)\n    return ''\n  }\n}\n\nexport const truncate = (input: unknown): string => {\n  const str = toSafeString(input)\n  if (str === '') {\n    return ''\n  }\n\n  // Check if we need to truncate and ensure STRING_FORMAT is respected\n  const encoder = new TextEncoder()\n  const buffer = encoder.encode(str)\n  if (buffer.length <= MAX_OUTPUT_SIZE) {\n    // Ensure STRING_FORMAT is respected\n    return new TextDecoder(STRING_FORMAT).decode(buffer)\n  }\n\n  // Truncate the buffer and ensure a valid string is returned\n  const truncatedBuffer = buffer.slice(0, MAX_OUTPUT_SIZE)\n  // fatal: false means we get U+FFFD at the end if truncation broke the encoding\n  const decoder = new TextDecoder(STRING_FORMAT, { fatal: false })\n  let truncatedStr = decoder.decode(truncatedBuffer)\n  if (truncatedStr.endsWith('\\uFFFD')) {\n    truncatedStr = truncatedStr.slice(0, -1)\n  }\n  return `${truncatedStr}... [truncated]`\n}\n\n/**\n * Extract available tool calls from the request parameters.\n * These are the tools provided to the LLM, not the tool calls in the response.\n */\nexport const extractAvailableToolCalls = (\n  provider: string,\n  params: any\n): ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null => {\n  if (provider === 'anthropic') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'gemini') {\n    if (params.config && params.config.tools) {\n      return params.config.tools\n    }\n\n    return null\n  } else if (provider === 'openai') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'vercel') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  }\n\n  return null\n}\n\nexport enum AIEvent {\n  Generation = '$ai_generation',\n  Embedding = '$ai_embedding',\n}\n\nexport type SendEventToPosthogParams = {\n  client: PostHog\n  eventType?: AIEvent\n  distinctId?: string\n  traceId: string\n  model: string\n  provider: string\n  input: any\n  output: any\n  latency: number\n  baseURL: string\n  httpStatus: number\n  usage?: TokenUsage\n  params: (\n    | ChatCompletionCreateParamsBase\n    | MessageCreateParams\n    | ResponseCreateParams\n    | ResponseCreateParamsWithTools\n    | EmbeddingCreateParams\n  ) &\n    MonitoringParams\n  isError?: boolean\n  error?: string\n  tools?: ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null\n  captureImmediate?: boolean\n}\n\nfunction sanitizeValues(obj: any): any {\n  if (obj === undefined || obj === null) {\n    return obj\n  }\n  const jsonSafe = JSON.parse(JSON.stringify(obj))\n  if (typeof jsonSafe === 'string') {\n    return Buffer.from(jsonSafe, STRING_FORMAT).toString(STRING_FORMAT)\n  } else if (Array.isArray(jsonSafe)) {\n    return jsonSafe.map(sanitizeValues)\n  } else if (jsonSafe && typeof jsonSafe === 'object') {\n    return Object.fromEntries(Object.entries(jsonSafe).map(([k, v]) => [k, sanitizeValues(v)]))\n  }\n  return jsonSafe\n}\n\nconst POSTHOG_PARAMS_MAP: Record<keyof MonitoringParams, string> = {\n  posthogDistinctId: 'distinctId',\n  posthogTraceId: 'traceId',\n  posthogProperties: 'properties',\n  posthogPrivacyMode: 'privacyMode',\n  posthogGroups: 'groups',\n  posthogModelOverride: 'modelOverride',\n  posthogProviderOverride: 'providerOverride',\n  posthogCostOverride: 'costOverride',\n  posthogCaptureImmediate: 'captureImmediate',\n}\n\nexport function extractPosthogParams<T>(body: T & MonitoringParams): {\n  providerParams: T\n  posthogParams: MonitoringEventPropertiesWithDefaults\n} {\n  const providerParams: Record<string, unknown> = {}\n  const posthogParams: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(body)) {\n    if (POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]) {\n      posthogParams[POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]] = value\n    } else if (key.startsWith('posthog')) {\n      console.warn(`Unknown Posthog parameter ${key}`)\n    } else {\n      providerParams[key] = value\n    }\n  }\n\n  return {\n    providerParams: providerParams as T,\n    posthogParams: addDefaults(posthogParams),\n  }\n}\n\nfunction addDefaults(params: MonitoringEventProperties): MonitoringEventPropertiesWithDefaults {\n  return {\n    ...params,\n    privacyMode: params.privacyMode ?? false,\n    traceId: params.traceId ?? uuidv4(),\n  }\n}\n\nexport const sendEventToPosthog = async ({\n  client,\n  eventType = AIEvent.Generation,\n  distinctId,\n  traceId,\n  model,\n  provider,\n  input,\n  output,\n  latency,\n  baseURL,\n  params,\n  httpStatus = 200,\n  usage = {},\n  isError = false,\n  error,\n  tools,\n  captureImmediate = false,\n}: SendEventToPosthogParams): Promise<void> => {\n  if (!client.capture) {\n    return Promise.resolve()\n  }\n  // sanitize input and output for UTF-8 validity\n  const safeInput = sanitizeValues(input)\n  const safeOutput = sanitizeValues(output)\n  const safeError = sanitizeValues(error)\n\n  let errorData = {}\n  if (isError) {\n    errorData = {\n      $ai_is_error: true,\n      $ai_error: safeError,\n    }\n  }\n  let costOverrideData = {}\n  if (params.posthogCostOverride) {\n    const inputCostUSD = (params.posthogCostOverride.inputCost ?? 0) * (usage.inputTokens ?? 0)\n    const outputCostUSD = (params.posthogCostOverride.outputCost ?? 0) * (usage.outputTokens ?? 0)\n    costOverrideData = {\n      $ai_input_cost_usd: inputCostUSD,\n      $ai_output_cost_usd: outputCostUSD,\n      $ai_total_cost_usd: inputCostUSD + outputCostUSD,\n    }\n  }\n\n  const additionalTokenValues = {\n    ...(usage.reasoningTokens ? { $ai_reasoning_tokens: usage.reasoningTokens } : {}),\n    ...(usage.cacheReadInputTokens ? { $ai_cache_read_input_tokens: usage.cacheReadInputTokens } : {}),\n    ...(usage.cacheCreationInputTokens ? { $ai_cache_creation_input_tokens: usage.cacheCreationInputTokens } : {}),\n  }\n\n  const properties = {\n    $ai_lib: 'posthog-ai',\n    $ai_lib_version: version,\n    $ai_provider: params.posthogProviderOverride ?? provider,\n    $ai_model: params.posthogModelOverride ?? model,\n    $ai_model_parameters: getModelParams(params),\n    $ai_input: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeInput),\n    $ai_output_choices: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeOutput),\n    $ai_http_status: httpStatus,\n    $ai_input_tokens: usage.inputTokens ?? 0,\n    ...(usage.outputTokens !== undefined ? { $ai_output_tokens: usage.outputTokens } : {}),\n    ...additionalTokenValues,\n    $ai_latency: latency,\n    $ai_trace_id: traceId,\n    $ai_base_url: baseURL,\n    ...params.posthogProperties,\n    ...(distinctId ? {} : { $process_person_profile: false }),\n    ...(tools ? { $ai_tools: tools } : {}),\n    ...errorData,\n    ...costOverrideData,\n  }\n\n  const event = {\n    distinctId: distinctId ?? traceId,\n    event: eventType,\n    properties,\n    groups: params.posthogGroups,\n  }\n\n  if (captureImmediate) {\n    // await capture promise to send single event in serverless environments\n    await client.captureImmediate(event)\n  } else {\n    client.capture(event)\n  }\n}\n","// Type guards for safer type checking\n\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string'\n}\n\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isString, isObject } from './typeGuards'\n\nconst REDACTED_IMAGE_PLACEHOLDER = '[base64 image redacted]'\n\n// ============================================\n// Base64 Detection Helpers\n// ============================================\n\nconst isBase64DataUrl = (str: string): boolean => {\n  return /^data:([^;]+);base64,/.test(str)\n}\n\nconst isValidUrl = (str: string): boolean => {\n  try {\n    new URL(str)\n    return true\n  } catch {\n    // Not an absolute URL, check if it's a relative URL or path\n    return str.startsWith('/') || str.startsWith('./') || str.startsWith('../')\n  }\n}\n\nconst isRawBase64 = (str: string): boolean => {\n  // Skip if it's a valid URL or path\n  if (isValidUrl(str)) {\n    return false\n  }\n\n  // Check if it's a valid base64 string\n  // Base64 images are typically at least a few hundred chars, but we'll be conservative\n  return str.length > 20 && /^[A-Za-z0-9+/]+=*$/.test(str)\n}\n\nexport function redactBase64DataUrl(str: string): string\nexport function redactBase64DataUrl(str: unknown): unknown\nexport function redactBase64DataUrl(str: unknown): unknown {\n  if (!isString(str)) return str\n\n  // Check for data URL format\n  if (isBase64DataUrl(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  // Check for raw base64 (Vercel sends raw base64 for inline images)\n  if (isRawBase64(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  return str\n}\n\n// ============================================\n// Common Message Processing\n// ============================================\n\ntype ContentTransformer = (item: unknown) => unknown\n\nconst processMessages = (messages: unknown, transformContent: ContentTransformer): unknown => {\n  if (!messages) return messages\n\n  const processContent = (content: unknown): unknown => {\n    if (typeof content === 'string') return content\n\n    if (!content) return content\n\n    if (Array.isArray(content)) {\n      return content.map(transformContent)\n    }\n\n    // Handle single object content\n    return transformContent(content)\n  }\n\n  const processMessage = (msg: unknown): unknown => {\n    if (!isObject(msg) || !('content' in msg)) return msg\n    return { ...msg, content: processContent(msg.content) }\n  }\n\n  // Handle both arrays and single messages\n  if (Array.isArray(messages)) {\n    return messages.map(processMessage)\n  }\n\n  return processMessage(messages)\n}\n\n// ============================================\n// Provider-Specific Image Sanitizers\n// ============================================\n\nconst sanitizeOpenAIImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle image_url format\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeOpenAIResponseImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle input_image format\n  if (item.type === 'input_image' && 'image_url' in item) {\n    return {\n      ...item,\n      image_url: redactBase64DataUrl(item.image_url),\n    }\n  }\n\n  return item\n}\n\nconst sanitizeAnthropicImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle Anthropic's image format\n  if (\n    item.type === 'image' &&\n    'source' in item &&\n    isObject(item.source) &&\n    item.source.type === 'base64' &&\n    'data' in item.source\n  ) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeGeminiPart = (part: unknown): unknown => {\n  if (!isObject(part)) return part\n\n  // Handle Gemini's inline data format\n  if ('inlineData' in part && isObject(part.inlineData) && 'data' in part.inlineData) {\n    return {\n      ...part,\n      inlineData: {\n        ...part.inlineData,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return part\n}\n\nconst processGeminiItem = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // If it has parts, process them\n  if ('parts' in item && item.parts) {\n    const parts = Array.isArray(item.parts) ? item.parts.map(sanitizeGeminiPart) : sanitizeGeminiPart(item.parts)\n\n    return { ...item, parts }\n  }\n\n  return item\n}\n\nconst sanitizeLangChainImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // OpenAI style\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  // Direct image with data field\n  if (item.type === 'image' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  // Anthropic style\n  if (item.type === 'image' && 'source' in item && isObject(item.source) && 'data' in item.source) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: redactBase64DataUrl(item.source.data),\n      },\n    }\n  }\n\n  // Google style\n  if (item.type === 'media' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  return item\n}\n\n// Export individual sanitizers for tree-shaking\nexport const sanitizeOpenAI = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIImage)\n}\n\nexport const sanitizeOpenAIResponse = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIResponseImage)\n}\n\nexport const sanitizeAnthropic = (data: unknown): unknown => {\n  return processMessages(data, sanitizeAnthropicImage)\n}\n\nexport const sanitizeGemini = (data: unknown): unknown => {\n  // Gemini has a different structure with 'parts' directly on items instead of 'content'\n  // So we need custom processing instead of using processMessages\n  if (!data) return data\n\n  if (Array.isArray(data)) {\n    return data.map(processGeminiItem)\n  }\n\n  return processGeminiItem(data)\n}\n\nexport const sanitizeLangChain = (data: unknown): unknown => {\n  return processMessages(data, sanitizeLangChainImage)\n}\n","import { OpenAI as OpenAIOrignal, ClientOptions } from 'openai'\nimport { PostHog } from 'posthog-node'\nimport {\n  formatResponseOpenAI,\n  MonitoringParams,\n  sendEventToPosthog,\n  extractAvailableToolCalls,\n  withPrivacyMode,\n  AIEvent,\n} from '../utils'\nimport type { APIPromise } from 'openai'\nimport type { Stream } from 'openai/streaming'\nimport type { ParsedResponse } from 'openai/resources/responses/responses'\nimport type { ResponseCreateParamsWithTools, ExtractParsedContentFromParams } from 'openai/lib/ResponsesParser'\nimport type { FormattedMessage, FormattedContent, FormattedFunctionCall } from '../types'\nimport { sanitizeOpenAI, sanitizeOpenAIResponse } from '../sanitization'\nimport { extractPosthogParams } from '../utils'\n\nconst Chat = OpenAIOrignal.Chat\nconst Completions = Chat.Completions\nconst Responses = OpenAIOrignal.Responses\nconst Embeddings = OpenAIOrignal.Embeddings\n\ntype ChatCompletion = OpenAIOrignal.ChatCompletion\ntype ChatCompletionChunk = OpenAIOrignal.ChatCompletionChunk\ntype ChatCompletionCreateParamsBase = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams\ntype ChatCompletionCreateParamsNonStreaming = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParamsNonStreaming\ntype ChatCompletionCreateParamsStreaming = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParamsStreaming\ntype ResponsesCreateParamsBase = OpenAIOrignal.Responses.ResponseCreateParams\ntype ResponsesCreateParamsNonStreaming = OpenAIOrignal.Responses.ResponseCreateParamsNonStreaming\ntype ResponsesCreateParamsStreaming = OpenAIOrignal.Responses.ResponseCreateParamsStreaming\ntype CreateEmbeddingResponse = OpenAIOrignal.CreateEmbeddingResponse\ntype EmbeddingCreateParams = OpenAIOrignal.EmbeddingCreateParams\n\ninterface MonitoringOpenAIConfig extends ClientOptions {\n  apiKey: string\n  posthog: PostHog\n  baseURL?: string\n}\n\ntype RequestOptions = Record<string, any>\n\nexport class PostHogOpenAI extends OpenAIOrignal {\n  private readonly phClient: PostHog\n  public chat: WrappedChat\n  public responses: WrappedResponses\n  public embeddings: WrappedEmbeddings\n\n  constructor(config: MonitoringOpenAIConfig) {\n    const { posthog, ...openAIConfig } = config\n    super(openAIConfig)\n    this.phClient = posthog\n    this.chat = new WrappedChat(this, this.phClient)\n    this.responses = new WrappedResponses(this, this.phClient)\n    this.embeddings = new WrappedEmbeddings(this, this.phClient)\n  }\n}\n\nexport class WrappedChat extends Chat {\n  constructor(parentClient: PostHogOpenAI, phClient: PostHog) {\n    super(parentClient)\n    this.completions = new WrappedCompletions(parentClient, phClient)\n  }\n\n  public completions: WrappedCompletions\n}\n\nexport class WrappedCompletions extends Completions {\n  private readonly phClient: PostHog\n  private readonly baseURL: string\n\n  constructor(client: OpenAIOrignal, phClient: PostHog) {\n    super(client)\n    this.phClient = phClient\n    this.baseURL = client.baseURL\n  }\n\n  // --- Overload #1: Non-streaming\n  public create(\n    body: ChatCompletionCreateParamsNonStreaming & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<ChatCompletion>\n\n  // --- Overload #2: Streaming\n  public create(\n    body: ChatCompletionCreateParamsStreaming & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<Stream<ChatCompletionChunk>>\n\n  // --- Overload #3: Generic base\n  public create(\n    body: ChatCompletionCreateParamsBase & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<ChatCompletion | Stream<ChatCompletionChunk>>\n\n  // --- Implementation Signature\n  public create(\n    body: ChatCompletionCreateParamsBase & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<ChatCompletion | Stream<ChatCompletionChunk>> {\n    const { providerParams: openAIParams, posthogParams } = extractPosthogParams(body)\n    const startTime = Date.now()\n\n    const parentPromise = super.create(openAIParams, options)\n\n    if (openAIParams.stream) {\n      return parentPromise.then((value) => {\n        if ('tee' in value) {\n          const [stream1, stream2] = value.tee()\n          ;(async () => {\n            try {\n              const contentBlocks: FormattedContent = []\n              let accumulatedContent = ''\n              let usage: {\n                inputTokens?: number\n                outputTokens?: number\n                reasoningTokens?: number\n                cacheReadInputTokens?: number\n              } = {\n                inputTokens: 0,\n                outputTokens: 0,\n              }\n\n              // Map to track in-progress tool calls\n              const toolCallsInProgress = new Map<\n                number,\n                {\n                  id: string\n                  name: string\n                  arguments: string\n                }\n              >()\n\n              for await (const chunk of stream1) {\n                const choice = chunk?.choices?.[0]\n\n                // Handle text content\n                const deltaContent = choice?.delta?.content\n                if (deltaContent) {\n                  accumulatedContent += deltaContent\n                }\n\n                // Handle tool calls\n                const deltaToolCalls = choice?.delta?.tool_calls\n                if (deltaToolCalls && Array.isArray(deltaToolCalls)) {\n                  for (const toolCall of deltaToolCalls) {\n                    const index = toolCall.index\n\n                    if (index !== undefined) {\n                      if (!toolCallsInProgress.has(index)) {\n                        // New tool call\n                        toolCallsInProgress.set(index, {\n                          id: toolCall.id || '',\n                          name: toolCall.function?.name || '',\n                          arguments: '',\n                        })\n                      }\n\n                      const inProgressCall = toolCallsInProgress.get(index)\n                      if (inProgressCall) {\n                        // Update tool call data\n                        if (toolCall.id) {\n                          inProgressCall.id = toolCall.id\n                        }\n                        if (toolCall.function?.name) {\n                          inProgressCall.name = toolCall.function.name\n                        }\n                        if (toolCall.function?.arguments) {\n                          inProgressCall.arguments += toolCall.function.arguments\n                        }\n                      }\n                    }\n                  }\n                }\n\n                // Handle usage information\n                if (chunk.usage) {\n                  usage = {\n                    inputTokens: chunk.usage.prompt_tokens ?? 0,\n                    outputTokens: chunk.usage.completion_tokens ?? 0,\n                    reasoningTokens: chunk.usage.completion_tokens_details?.reasoning_tokens ?? 0,\n                    cacheReadInputTokens: chunk.usage.prompt_tokens_details?.cached_tokens ?? 0,\n                  }\n                }\n              }\n\n              // Build final content blocks\n              if (accumulatedContent) {\n                contentBlocks.push({ type: 'text', text: accumulatedContent })\n              }\n\n              // Add completed tool calls to content blocks\n              for (const toolCall of toolCallsInProgress.values()) {\n                if (toolCall.name) {\n                  contentBlocks.push({\n                    type: 'function',\n                    id: toolCall.id,\n                    function: {\n                      name: toolCall.name,\n                      arguments: toolCall.arguments,\n                    },\n                  } as FormattedFunctionCall)\n                }\n              }\n\n              // Format output to match non-streaming version\n              const formattedOutput: FormattedMessage[] =\n                contentBlocks.length > 0\n                  ? [\n                      {\n                        role: 'assistant',\n                        content: contentBlocks,\n                      },\n                    ]\n                  : [\n                      {\n                        role: 'assistant',\n                        content: [{ type: 'text', text: '' }],\n                      },\n                    ]\n\n              const latency = (Date.now() - startTime) / 1000\n              const availableTools = extractAvailableToolCalls('openai', openAIParams)\n              await sendEventToPosthog({\n                client: this.phClient,\n                ...posthogParams,\n                model: openAIParams.model,\n                provider: 'openai',\n                input: sanitizeOpenAI(openAIParams.messages),\n                output: formattedOutput,\n                latency,\n                baseURL: this.baseURL,\n                params: body,\n                httpStatus: 200,\n                usage,\n                tools: availableTools,\n              })\n            } catch (error: unknown) {\n              const httpStatus =\n                error && typeof error === 'object' && 'status' in error\n                  ? ((error as { status?: number }).status ?? 500)\n                  : 500\n\n              await sendEventToPosthog({\n                client: this.phClient,\n                ...posthogParams,\n                model: openAIParams.model,\n                provider: 'openai',\n                input: sanitizeOpenAI(openAIParams.messages),\n                output: [],\n                latency: 0,\n                baseURL: this.baseURL,\n                params: body,\n                httpStatus,\n                usage: { inputTokens: 0, outputTokens: 0 },\n                isError: true,\n                error: JSON.stringify(error),\n              })\n            }\n          })()\n\n          // Return the other stream to the user\n          return stream2\n        }\n        return value\n      }) as APIPromise<Stream<ChatCompletionChunk>>\n    } else {\n      const wrappedPromise = parentPromise.then(\n        async (result) => {\n          if ('choices' in result) {\n            const latency = (Date.now() - startTime) / 1000\n            const availableTools = extractAvailableToolCalls('openai', openAIParams)\n            await sendEventToPosthog({\n              client: this.phClient,\n              ...posthogParams,\n              model: openAIParams.model,\n              provider: 'openai',\n              input: sanitizeOpenAI(openAIParams.messages),\n              output: formatResponseOpenAI(result),\n              latency,\n              baseURL: this.baseURL,\n              params: body,\n              httpStatus: 200,\n              usage: {\n                inputTokens: result.usage?.prompt_tokens ?? 0,\n                outputTokens: result.usage?.completion_tokens ?? 0,\n                reasoningTokens: result.usage?.completion_tokens_details?.reasoning_tokens ?? 0,\n                cacheReadInputTokens: result.usage?.prompt_tokens_details?.cached_tokens ?? 0,\n              },\n              tools: availableTools,\n            })\n          }\n          return result\n        },\n        async (error: unknown) => {\n          const httpStatus =\n            error && typeof error === 'object' && 'status' in error\n              ? ((error as { status?: number }).status ?? 500)\n              : 500\n\n          await sendEventToPosthog({\n            client: this.phClient,\n            ...posthogParams,\n            model: String(openAIParams.model ?? ''),\n            provider: 'openai',\n            input: sanitizeOpenAI(openAIParams.messages),\n            output: [],\n            latency: 0,\n            baseURL: this.baseURL,\n            params: body,\n            httpStatus,\n            usage: {\n              inputTokens: 0,\n              outputTokens: 0,\n            },\n            isError: true,\n            error: JSON.stringify(error),\n          })\n          throw error\n        }\n      ) as APIPromise<ChatCompletion>\n\n      return wrappedPromise\n    }\n  }\n}\n\nexport class WrappedResponses extends Responses {\n  private readonly phClient: PostHog\n  private readonly baseURL: string\n\n  constructor(client: OpenAIOrignal, phClient: PostHog) {\n    super(client)\n    this.phClient = phClient\n    this.baseURL = client.baseURL\n  }\n\n  // --- Overload #1: Non-streaming\n  public create(\n    body: ResponsesCreateParamsNonStreaming & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<OpenAIOrignal.Responses.Response>\n\n  // --- Overload #2: Streaming\n  public create(\n    body: ResponsesCreateParamsStreaming & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<Stream<OpenAIOrignal.Responses.ResponseStreamEvent>>\n\n  // --- Overload #3: Generic base\n  public create(\n    body: ResponsesCreateParamsBase & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<OpenAIOrignal.Responses.Response | Stream<OpenAIOrignal.Responses.ResponseStreamEvent>>\n\n  // --- Implementation Signature\n  public create(\n    body: ResponsesCreateParamsBase & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<OpenAIOrignal.Responses.Response | Stream<OpenAIOrignal.Responses.ResponseStreamEvent>> {\n    const { providerParams: openAIParams, posthogParams } = extractPosthogParams(body)\n    const startTime = Date.now()\n\n    const parentPromise = super.create(openAIParams, options)\n\n    if (openAIParams.stream) {\n      return parentPromise.then((value) => {\n        if ('tee' in value && typeof (value as any).tee === 'function') {\n          const [stream1, stream2] = (value as any).tee()\n          ;(async () => {\n            try {\n              let finalContent: any[] = []\n              let usage: {\n                inputTokens?: number\n                outputTokens?: number\n                reasoningTokens?: number\n                cacheReadInputTokens?: number\n              } = {\n                inputTokens: 0,\n                outputTokens: 0,\n              }\n\n              for await (const chunk of stream1) {\n                if (\n                  chunk.type === 'response.completed' &&\n                  'response' in chunk &&\n                  chunk.response?.output &&\n                  chunk.response.output.length > 0\n                ) {\n                  finalContent = chunk.response.output\n                }\n                if ('response' in chunk && chunk.response?.usage) {\n                  usage = {\n                    inputTokens: chunk.response.usage.input_tokens ?? 0,\n                    outputTokens: chunk.response.usage.output_tokens ?? 0,\n                    reasoningTokens: chunk.response.usage.output_tokens_details?.reasoning_tokens ?? 0,\n                    cacheReadInputTokens: chunk.response.usage.input_tokens_details?.cached_tokens ?? 0,\n                  }\n                }\n              }\n\n              const latency = (Date.now() - startTime) / 1000\n              const availableTools = extractAvailableToolCalls('openai', openAIParams)\n              await sendEventToPosthog({\n                client: this.phClient,\n                ...posthogParams,\n                //@ts-expect-error\n                model: openAIParams.model,\n                provider: 'openai',\n                input: sanitizeOpenAIResponse(openAIParams.input),\n                output: finalContent,\n                latency,\n                baseURL: this.baseURL,\n                params: body,\n                httpStatus: 200,\n                usage,\n                tools: availableTools,\n              })\n            } catch (error: unknown) {\n              const httpStatus =\n                error && typeof error === 'object' && 'status' in error\n                  ? ((error as { status?: number }).status ?? 500)\n                  : 500\n\n              await sendEventToPosthog({\n                client: this.phClient,\n                ...posthogParams,\n                //@ts-expect-error\n                model: openAIParams.model,\n                provider: 'openai',\n                input: sanitizeOpenAIResponse(openAIParams.input),\n                output: [],\n                latency: 0,\n                baseURL: this.baseURL,\n                params: body,\n                httpStatus,\n                usage: { inputTokens: 0, outputTokens: 0 },\n                isError: true,\n                error: JSON.stringify(error),\n              })\n            }\n          })()\n\n          return stream2\n        }\n        return value\n      }) as APIPromise<Stream<OpenAIOrignal.Responses.ResponseStreamEvent>>\n    } else {\n      const wrappedPromise = parentPromise.then(\n        async (result) => {\n          if ('output' in result) {\n            const latency = (Date.now() - startTime) / 1000\n            const availableTools = extractAvailableToolCalls('openai', openAIParams)\n            await sendEventToPosthog({\n              client: this.phClient,\n              ...posthogParams,\n              //@ts-expect-error\n              model: openAIParams.model,\n              provider: 'openai',\n              input: sanitizeOpenAIResponse(openAIParams.input),\n              output: formatResponseOpenAI({ output: result.output }),\n              latency,\n              baseURL: this.baseURL,\n              params: body,\n              httpStatus: 200,\n              usage: {\n                inputTokens: result.usage?.input_tokens ?? 0,\n                outputTokens: result.usage?.output_tokens ?? 0,\n                reasoningTokens: result.usage?.output_tokens_details?.reasoning_tokens ?? 0,\n                cacheReadInputTokens: result.usage?.input_tokens_details?.cached_tokens ?? 0,\n              },\n              tools: availableTools,\n            })\n          }\n          return result\n        },\n        async (error: unknown) => {\n          const httpStatus =\n            error && typeof error === 'object' && 'status' in error\n              ? ((error as { status?: number }).status ?? 500)\n              : 500\n\n          await sendEventToPosthog({\n            client: this.phClient,\n            ...posthogParams,\n            model: String(openAIParams.model ?? ''),\n            provider: 'openai',\n            input: sanitizeOpenAIResponse(openAIParams.input),\n            output: [],\n            latency: 0,\n            baseURL: this.baseURL,\n            params: body,\n            httpStatus,\n            usage: {\n              inputTokens: 0,\n              outputTokens: 0,\n            },\n            isError: true,\n            error: JSON.stringify(error),\n          })\n          throw error\n        }\n      ) as APIPromise<OpenAIOrignal.Responses.Response>\n\n      return wrappedPromise\n    }\n  }\n\n  public parse<Params extends ResponseCreateParamsWithTools, ParsedT = ExtractParsedContentFromParams<Params>>(\n    body: Params & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<ParsedResponse<ParsedT>> {\n    const { providerParams: openAIParams, posthogParams } = extractPosthogParams(body)\n    const startTime = Date.now()\n\n    const originalCreate = super.create.bind(this)\n    const originalSelf = this as any\n    const tempCreate = originalSelf.create\n    originalSelf.create = originalCreate\n\n    try {\n      const parentPromise = super.parse(openAIParams, options)\n\n      const wrappedPromise = parentPromise.then(\n        async (result) => {\n          const latency = (Date.now() - startTime) / 1000\n          await sendEventToPosthog({\n            client: this.phClient,\n            ...posthogParams,\n            model: String(openAIParams.model ?? ''),\n            provider: 'openai',\n            input: sanitizeOpenAIResponse(openAIParams.input),\n            output: result.output,\n            latency,\n            baseURL: this.baseURL,\n            params: body,\n            httpStatus: 200,\n            usage: {\n              inputTokens: result.usage?.input_tokens ?? 0,\n              outputTokens: result.usage?.output_tokens ?? 0,\n              reasoningTokens: result.usage?.output_tokens_details?.reasoning_tokens ?? 0,\n              cacheReadInputTokens: result.usage?.input_tokens_details?.cached_tokens ?? 0,\n            },\n          })\n          return result\n        },\n        async (error: unknown) => {\n          const httpStatus =\n            error && typeof error === 'object' && 'status' in error\n              ? ((error as { status?: number }).status ?? 500)\n              : 500\n\n          await sendEventToPosthog({\n            client: this.phClient,\n            ...posthogParams,\n            model: String(openAIParams.model ?? ''),\n            provider: 'openai',\n            input: sanitizeOpenAIResponse(openAIParams.input),\n            output: [],\n            latency: 0,\n            baseURL: this.baseURL,\n            params: body,\n            httpStatus,\n            usage: {\n              inputTokens: 0,\n              outputTokens: 0,\n            },\n            isError: true,\n            error: JSON.stringify(error),\n          })\n          throw error\n        }\n      )\n\n      return wrappedPromise as APIPromise<ParsedResponse<ParsedT>>\n    } finally {\n      // Restore our wrapped create method\n      originalSelf.create = tempCreate\n    }\n  }\n}\n\nexport class WrappedEmbeddings extends Embeddings {\n  private readonly phClient: PostHog\n  private readonly baseURL: string\n\n  constructor(client: OpenAIOrignal, phClient: PostHog) {\n    super(client)\n    this.phClient = phClient\n    this.baseURL = client.baseURL\n  }\n\n  public create(\n    body: EmbeddingCreateParams & MonitoringParams,\n    options?: RequestOptions\n  ): APIPromise<CreateEmbeddingResponse> {\n    const { providerParams: openAIParams, posthogParams } = extractPosthogParams(body)\n    const startTime = Date.now()\n\n    const parentPromise = super.create(openAIParams, options)\n\n    const wrappedPromise = parentPromise.then(\n      async (result) => {\n        const latency = (Date.now() - startTime) / 1000\n        await sendEventToPosthog({\n          client: this.phClient,\n          ...posthogParams,\n          eventType: AIEvent.Embedding,\n          model: openAIParams.model,\n          provider: 'openai',\n          input: withPrivacyMode(this.phClient, posthogParams.privacyMode, openAIParams.input),\n          output: null, // Embeddings don't have output content\n          latency,\n          baseURL: this.baseURL,\n          params: body,\n          httpStatus: 200,\n          usage: {\n            inputTokens: result.usage?.prompt_tokens ?? 0,\n          },\n        })\n        return result\n      },\n      async (error: unknown) => {\n        const httpStatus =\n          error && typeof error === 'object' && 'status' in error ? ((error as { status?: number }).status ?? 500) : 500\n\n        await sendEventToPosthog({\n          client: this.phClient,\n          eventType: AIEvent.Embedding,\n          ...posthogParams,\n          model: openAIParams.model,\n          provider: 'openai',\n          input: withPrivacyMode(this.phClient, posthogParams.privacyMode, openAIParams.input),\n          output: null, // Embeddings don't have output content\n          latency: 0,\n          baseURL: this.baseURL,\n          params: body,\n          httpStatus,\n          usage: {\n            inputTokens: 0,\n          },\n          isError: true,\n          error: JSON.stringify(error),\n        })\n        throw error\n      }\n    ) as APIPromise<CreateEmbeddingResponse>\n\n    return wrappedPromise\n  }\n}\n\nexport default PostHogOpenAI\n\nexport { PostHogOpenAI as OpenAI }\n"],"names":["STRING_FORMAT","getModelParams","params","modelParams","paramKeys","key","undefined","formatResponseOpenAI","response","output","choices","choice","content","role","message","push","type","text","tool_calls","toolCall","id","function","name","arguments","length","item","Array","isArray","contentItem","image_url","image","String","call_id","withPrivacyMode","client","privacyMode","input","privacy_mode","extractAvailableToolCalls","provider","tools","AIEvent","sanitizeValues","obj","jsonSafe","JSON","parse","stringify","Buffer","from","toString","map","Object","fromEntries","entries","k","v","POSTHOG_PARAMS_MAP","posthogDistinctId","posthogTraceId","posthogProperties","posthogPrivacyMode","posthogGroups","posthogModelOverride","posthogProviderOverride","posthogCostOverride","posthogCaptureImmediate","extractPosthogParams","body","providerParams","posthogParams","value","startsWith","console","warn","addDefaults","traceId","uuidv4","sendEventToPosthog","eventType","Generation","distinctId","model","latency","baseURL","httpStatus","usage","isError","error","captureImmediate","capture","Promise","resolve","safeInput","safeOutput","safeError","errorData","$ai_is_error","$ai_error","costOverrideData","inputCostUSD","inputCost","inputTokens","outputCostUSD","outputCost","outputTokens","$ai_input_cost_usd","$ai_output_cost_usd","$ai_total_cost_usd","additionalTokenValues","reasoningTokens","$ai_reasoning_tokens","cacheReadInputTokens","$ai_cache_read_input_tokens","cacheCreationInputTokens","$ai_cache_creation_input_tokens","properties","$ai_lib","$ai_lib_version","version","$ai_provider","$ai_model","$ai_model_parameters","$ai_input","$ai_output_choices","$ai_http_status","$ai_input_tokens","$ai_output_tokens","$ai_latency","$ai_trace_id","$ai_base_url","$process_person_profile","$ai_tools","event","groups","isString","isObject","REDACTED_IMAGE_PLACEHOLDER","isBase64DataUrl","str","test","isValidUrl","URL","isRawBase64","redactBase64DataUrl","processMessages","messages","transformContent","processContent","processMessage","msg","sanitizeOpenAIImage","url","sanitizeOpenAIResponseImage","sanitizeOpenAI","data","sanitizeOpenAIResponse","Chat","OpenAIOrignal","Completions","Responses","Embeddings","PostHogOpenAI","constructor","config","posthog","openAIConfig","phClient","chat","WrappedChat","responses","WrappedResponses","embeddings","WrappedEmbeddings","parentClient","completions","WrappedCompletions","create","options","openAIParams","startTime","Date","now","parentPromise","stream","then","stream1","stream2","tee","contentBlocks","accumulatedContent","toolCallsInProgress","Map","chunk","deltaContent","delta","deltaToolCalls","index","has","set","inProgressCall","get","prompt_tokens","completion_tokens","completion_tokens_details","reasoning_tokens","prompt_tokens_details","cached_tokens","values","formattedOutput","availableTools","status","wrappedPromise","result","finalContent","input_tokens","output_tokens","output_tokens_details","input_tokens_details","originalCreate","bind","originalSelf","tempCreate","Embedding"],"mappings":"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"}