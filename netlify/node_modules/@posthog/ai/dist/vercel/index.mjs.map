{"version":3,"file":"index.mjs","sources":["../../src/utils.ts","../../src/typeGuards.ts","../../src/sanitization.ts","../../src/vercel/middleware.ts"],"sourcesContent":["import { PostHog } from 'posthog-node'\nimport { Buffer } from 'buffer'\nimport OpenAIOrignal from 'openai'\nimport AnthropicOriginal from '@anthropic-ai/sdk'\nimport type { ChatCompletionTool } from 'openai/resources/chat/completions'\nimport type { ResponseCreateParamsWithTools } from 'openai/lib/ResponsesParser'\nimport type { Tool as GeminiTool } from '@google/genai'\nimport type { FormattedMessage, FormattedContent, TokenUsage } from './types'\nimport { version } from '../package.json'\nimport { v4 as uuidv4 } from 'uuid'\n\ntype ChatCompletionCreateParamsBase = OpenAIOrignal.Chat.Completions.ChatCompletionCreateParams\ntype MessageCreateParams = AnthropicOriginal.Messages.MessageCreateParams\ntype ResponseCreateParams = OpenAIOrignal.Responses.ResponseCreateParams\ntype EmbeddingCreateParams = OpenAIOrignal.EmbeddingCreateParams\ntype AnthropicTool = AnthropicOriginal.Tool\n\n// limit large outputs by truncating to 200kb (approx 200k bytes)\nexport const MAX_OUTPUT_SIZE = 200000\nconst STRING_FORMAT = 'utf8'\n\nexport interface MonitoringEventPropertiesWithDefaults {\n  distinctId?: string\n  traceId: string\n  properties?: Record<string, any>\n  privacyMode: boolean\n  groups?: Record<string, any>\n  modelOverride?: string\n  providerOverride?: string\n  costOverride?: CostOverride\n  captureImmediate?: boolean\n}\n\nexport type MonitoringEventProperties = Partial<MonitoringEventPropertiesWithDefaults>\n\nexport type MonitoringParams = {\n  [K in keyof MonitoringEventProperties as `posthog${Capitalize<string & K>}`]: MonitoringEventProperties[K]\n}\n\nexport interface CostOverride {\n  inputCost: number\n  outputCost: number\n}\n\nexport const getModelParams = (\n  params:\n    | ((\n        | ChatCompletionCreateParamsBase\n        | MessageCreateParams\n        | ResponseCreateParams\n        | ResponseCreateParamsWithTools\n        | EmbeddingCreateParams\n      ) &\n        MonitoringParams)\n    | null\n): Record<string, any> => {\n  if (!params) {\n    return {}\n  }\n  const modelParams: Record<string, any> = {}\n  const paramKeys = [\n    'temperature',\n    'max_tokens',\n    'max_completion_tokens',\n    'top_p',\n    'frequency_penalty',\n    'presence_penalty',\n    'n',\n    'stop',\n    'stream',\n    'streaming',\n  ] as const\n\n  for (const key of paramKeys) {\n    if (key in params && (params as any)[key] !== undefined) {\n      modelParams[key] = (params as any)[key]\n    }\n  }\n  return modelParams\n}\n\n/**\n * Helper to format responses (non-streaming) for consumption, mirroring Python's openai vs. anthropic approach.\n */\nexport const formatResponse = (response: any, provider: string): FormattedMessage[] => {\n  if (!response) {\n    return []\n  }\n  if (provider === 'anthropic') {\n    return formatResponseAnthropic(response)\n  } else if (provider === 'openai') {\n    return formatResponseOpenAI(response)\n  } else if (provider === 'gemini') {\n    return formatResponseGemini(response)\n  }\n  return []\n}\n\nexport const formatResponseAnthropic = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n  const content: FormattedContent = []\n\n  for (const choice of response.content ?? []) {\n    if (choice?.type === 'text' && choice?.text) {\n      content.push({ type: 'text', text: choice.text })\n    } else if (choice?.type === 'tool_use' && choice?.name && choice?.id) {\n      content.push({\n        type: 'function',\n        id: choice.id,\n        function: {\n          name: choice.name,\n          arguments: choice.input || {},\n        },\n      })\n    }\n  }\n\n  if (content.length > 0) {\n    output.push({\n      role: 'assistant',\n      content,\n    })\n  }\n\n  return output\n}\n\nexport const formatResponseOpenAI = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.choices) {\n    for (const choice of response.choices) {\n      const content: FormattedContent = []\n      let role = 'assistant'\n\n      if (choice.message) {\n        if (choice.message.role) {\n          role = choice.message.role\n        }\n\n        if (choice.message.content) {\n          content.push({ type: 'text', text: choice.message.content })\n        }\n\n        if (choice.message.tool_calls) {\n          for (const toolCall of choice.message.tool_calls) {\n            content.push({\n              type: 'function',\n              id: toolCall.id,\n              function: {\n                name: toolCall.function.name,\n                arguments: toolCall.function.arguments,\n              },\n            })\n          }\n        }\n      }\n\n      if (content.length > 0) {\n        output.push({\n          role,\n          content,\n        })\n      }\n    }\n  }\n\n  // Handle Responses API format\n  if (response.output) {\n    const content: FormattedContent = []\n    let role = 'assistant'\n\n    for (const item of response.output) {\n      if (item.type === 'message') {\n        role = item.role\n\n        if (item.content && Array.isArray(item.content)) {\n          for (const contentItem of item.content) {\n            if (contentItem.type === 'output_text' && contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.text) {\n              content.push({ type: 'text', text: contentItem.text })\n            } else if (contentItem.type === 'input_image' && contentItem.image_url) {\n              content.push({\n                type: 'image',\n                image: contentItem.image_url,\n              })\n            }\n          }\n        } else if (item.content) {\n          content.push({ type: 'text', text: String(item.content) })\n        }\n      } else if (item.type === 'function_call') {\n        content.push({\n          type: 'function',\n          id: item.call_id || item.id || '',\n          function: {\n            name: item.name,\n            arguments: item.arguments || {},\n          },\n        })\n      }\n    }\n\n    if (content.length > 0) {\n      output.push({\n        role,\n        content,\n      })\n    }\n  }\n\n  return output\n}\n\nexport const formatResponseGemini = (response: any): FormattedMessage[] => {\n  const output: FormattedMessage[] = []\n\n  if (response.candidates && Array.isArray(response.candidates)) {\n    for (const candidate of response.candidates) {\n      if (candidate.content && candidate.content.parts) {\n        const content: FormattedContent = []\n\n        for (const part of candidate.content.parts) {\n          if (part.text) {\n            content.push({ type: 'text', text: part.text })\n          } else if (part.functionCall) {\n            content.push({\n              type: 'function',\n              function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args,\n              },\n            })\n          }\n        }\n\n        if (content.length > 0) {\n          output.push({\n            role: 'assistant',\n            content,\n          })\n        }\n      } else if (candidate.text) {\n        output.push({\n          role: 'assistant',\n          content: [{ type: 'text', text: candidate.text }],\n        })\n      }\n    }\n  } else if (response.text) {\n    output.push({\n      role: 'assistant',\n      content: [{ type: 'text', text: response.text }],\n    })\n  }\n\n  return output\n}\n\nexport const mergeSystemPrompt = (params: MessageCreateParams & MonitoringParams, provider: string): any => {\n  if (provider == 'anthropic') {\n    const messages = params.messages || []\n    if (!(params as any).system) {\n      return messages\n    }\n    const systemMessage = (params as any).system\n    return [{ role: 'system', content: systemMessage }, ...messages]\n  }\n  return params.messages\n}\n\nexport const withPrivacyMode = (client: PostHog, privacyMode: boolean, input: any): any => {\n  return (client as any).privacy_mode || privacyMode ? null : input\n}\n\nfunction toSafeString(input: unknown): string {\n  if (input === undefined || input === null) {\n    return ''\n  }\n  if (typeof input === 'string') {\n    return input\n  }\n  try {\n    return JSON.stringify(input)\n  } catch {\n    console.warn('Failed to stringify input', input)\n    return ''\n  }\n}\n\nexport const truncate = (input: unknown): string => {\n  const str = toSafeString(input)\n  if (str === '') {\n    return ''\n  }\n\n  // Check if we need to truncate and ensure STRING_FORMAT is respected\n  const encoder = new TextEncoder()\n  const buffer = encoder.encode(str)\n  if (buffer.length <= MAX_OUTPUT_SIZE) {\n    // Ensure STRING_FORMAT is respected\n    return new TextDecoder(STRING_FORMAT).decode(buffer)\n  }\n\n  // Truncate the buffer and ensure a valid string is returned\n  const truncatedBuffer = buffer.slice(0, MAX_OUTPUT_SIZE)\n  // fatal: false means we get U+FFFD at the end if truncation broke the encoding\n  const decoder = new TextDecoder(STRING_FORMAT, { fatal: false })\n  let truncatedStr = decoder.decode(truncatedBuffer)\n  if (truncatedStr.endsWith('\\uFFFD')) {\n    truncatedStr = truncatedStr.slice(0, -1)\n  }\n  return `${truncatedStr}... [truncated]`\n}\n\n/**\n * Extract available tool calls from the request parameters.\n * These are the tools provided to the LLM, not the tool calls in the response.\n */\nexport const extractAvailableToolCalls = (\n  provider: string,\n  params: any\n): ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null => {\n  if (provider === 'anthropic') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'gemini') {\n    if (params.config && params.config.tools) {\n      return params.config.tools\n    }\n\n    return null\n  } else if (provider === 'openai') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  } else if (provider === 'vercel') {\n    if (params.tools) {\n      return params.tools\n    }\n\n    return null\n  }\n\n  return null\n}\n\nexport enum AIEvent {\n  Generation = '$ai_generation',\n  Embedding = '$ai_embedding',\n}\n\nexport type SendEventToPosthogParams = {\n  client: PostHog\n  eventType?: AIEvent\n  distinctId?: string\n  traceId: string\n  model: string\n  provider: string\n  input: any\n  output: any\n  latency: number\n  baseURL: string\n  httpStatus: number\n  usage?: TokenUsage\n  params: (\n    | ChatCompletionCreateParamsBase\n    | MessageCreateParams\n    | ResponseCreateParams\n    | ResponseCreateParamsWithTools\n    | EmbeddingCreateParams\n  ) &\n    MonitoringParams\n  isError?: boolean\n  error?: string\n  tools?: ChatCompletionTool[] | AnthropicTool[] | GeminiTool[] | null\n  captureImmediate?: boolean\n}\n\nfunction sanitizeValues(obj: any): any {\n  if (obj === undefined || obj === null) {\n    return obj\n  }\n  const jsonSafe = JSON.parse(JSON.stringify(obj))\n  if (typeof jsonSafe === 'string') {\n    return Buffer.from(jsonSafe, STRING_FORMAT).toString(STRING_FORMAT)\n  } else if (Array.isArray(jsonSafe)) {\n    return jsonSafe.map(sanitizeValues)\n  } else if (jsonSafe && typeof jsonSafe === 'object') {\n    return Object.fromEntries(Object.entries(jsonSafe).map(([k, v]) => [k, sanitizeValues(v)]))\n  }\n  return jsonSafe\n}\n\nconst POSTHOG_PARAMS_MAP: Record<keyof MonitoringParams, string> = {\n  posthogDistinctId: 'distinctId',\n  posthogTraceId: 'traceId',\n  posthogProperties: 'properties',\n  posthogPrivacyMode: 'privacyMode',\n  posthogGroups: 'groups',\n  posthogModelOverride: 'modelOverride',\n  posthogProviderOverride: 'providerOverride',\n  posthogCostOverride: 'costOverride',\n  posthogCaptureImmediate: 'captureImmediate',\n}\n\nexport function extractPosthogParams<T>(body: T & MonitoringParams): {\n  providerParams: T\n  posthogParams: MonitoringEventPropertiesWithDefaults\n} {\n  const providerParams: Record<string, unknown> = {}\n  const posthogParams: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(body)) {\n    if (POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]) {\n      posthogParams[POSTHOG_PARAMS_MAP[key as keyof MonitoringParams]] = value\n    } else if (key.startsWith('posthog')) {\n      console.warn(`Unknown Posthog parameter ${key}`)\n    } else {\n      providerParams[key] = value\n    }\n  }\n\n  return {\n    providerParams: providerParams as T,\n    posthogParams: addDefaults(posthogParams),\n  }\n}\n\nfunction addDefaults(params: MonitoringEventProperties): MonitoringEventPropertiesWithDefaults {\n  return {\n    ...params,\n    privacyMode: params.privacyMode ?? false,\n    traceId: params.traceId ?? uuidv4(),\n  }\n}\n\nexport const sendEventToPosthog = async ({\n  client,\n  eventType = AIEvent.Generation,\n  distinctId,\n  traceId,\n  model,\n  provider,\n  input,\n  output,\n  latency,\n  baseURL,\n  params,\n  httpStatus = 200,\n  usage = {},\n  isError = false,\n  error,\n  tools,\n  captureImmediate = false,\n}: SendEventToPosthogParams): Promise<void> => {\n  if (!client.capture) {\n    return Promise.resolve()\n  }\n  // sanitize input and output for UTF-8 validity\n  const safeInput = sanitizeValues(input)\n  const safeOutput = sanitizeValues(output)\n  const safeError = sanitizeValues(error)\n\n  let errorData = {}\n  if (isError) {\n    errorData = {\n      $ai_is_error: true,\n      $ai_error: safeError,\n    }\n  }\n  let costOverrideData = {}\n  if (params.posthogCostOverride) {\n    const inputCostUSD = (params.posthogCostOverride.inputCost ?? 0) * (usage.inputTokens ?? 0)\n    const outputCostUSD = (params.posthogCostOverride.outputCost ?? 0) * (usage.outputTokens ?? 0)\n    costOverrideData = {\n      $ai_input_cost_usd: inputCostUSD,\n      $ai_output_cost_usd: outputCostUSD,\n      $ai_total_cost_usd: inputCostUSD + outputCostUSD,\n    }\n  }\n\n  const additionalTokenValues = {\n    ...(usage.reasoningTokens ? { $ai_reasoning_tokens: usage.reasoningTokens } : {}),\n    ...(usage.cacheReadInputTokens ? { $ai_cache_read_input_tokens: usage.cacheReadInputTokens } : {}),\n    ...(usage.cacheCreationInputTokens ? { $ai_cache_creation_input_tokens: usage.cacheCreationInputTokens } : {}),\n  }\n\n  const properties = {\n    $ai_lib: 'posthog-ai',\n    $ai_lib_version: version,\n    $ai_provider: params.posthogProviderOverride ?? provider,\n    $ai_model: params.posthogModelOverride ?? model,\n    $ai_model_parameters: getModelParams(params),\n    $ai_input: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeInput),\n    $ai_output_choices: withPrivacyMode(client, params.posthogPrivacyMode ?? false, safeOutput),\n    $ai_http_status: httpStatus,\n    $ai_input_tokens: usage.inputTokens ?? 0,\n    ...(usage.outputTokens !== undefined ? { $ai_output_tokens: usage.outputTokens } : {}),\n    ...additionalTokenValues,\n    $ai_latency: latency,\n    $ai_trace_id: traceId,\n    $ai_base_url: baseURL,\n    ...params.posthogProperties,\n    ...(distinctId ? {} : { $process_person_profile: false }),\n    ...(tools ? { $ai_tools: tools } : {}),\n    ...errorData,\n    ...costOverrideData,\n  }\n\n  const event = {\n    distinctId: distinctId ?? traceId,\n    event: eventType,\n    properties,\n    groups: params.posthogGroups,\n  }\n\n  if (captureImmediate) {\n    // await capture promise to send single event in serverless environments\n    await client.captureImmediate(event)\n  } else {\n    client.capture(event)\n  }\n}\n","// Type guards for safer type checking\n\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string'\n}\n\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isString, isObject } from './typeGuards'\n\nconst REDACTED_IMAGE_PLACEHOLDER = '[base64 image redacted]'\n\n// ============================================\n// Base64 Detection Helpers\n// ============================================\n\nconst isBase64DataUrl = (str: string): boolean => {\n  return /^data:([^;]+);base64,/.test(str)\n}\n\nconst isValidUrl = (str: string): boolean => {\n  try {\n    new URL(str)\n    return true\n  } catch {\n    // Not an absolute URL, check if it's a relative URL or path\n    return str.startsWith('/') || str.startsWith('./') || str.startsWith('../')\n  }\n}\n\nconst isRawBase64 = (str: string): boolean => {\n  // Skip if it's a valid URL or path\n  if (isValidUrl(str)) {\n    return false\n  }\n\n  // Check if it's a valid base64 string\n  // Base64 images are typically at least a few hundred chars, but we'll be conservative\n  return str.length > 20 && /^[A-Za-z0-9+/]+=*$/.test(str)\n}\n\nexport function redactBase64DataUrl(str: string): string\nexport function redactBase64DataUrl(str: unknown): unknown\nexport function redactBase64DataUrl(str: unknown): unknown {\n  if (!isString(str)) return str\n\n  // Check for data URL format\n  if (isBase64DataUrl(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  // Check for raw base64 (Vercel sends raw base64 for inline images)\n  if (isRawBase64(str)) {\n    return REDACTED_IMAGE_PLACEHOLDER\n  }\n\n  return str\n}\n\n// ============================================\n// Common Message Processing\n// ============================================\n\ntype ContentTransformer = (item: unknown) => unknown\n\nconst processMessages = (messages: unknown, transformContent: ContentTransformer): unknown => {\n  if (!messages) return messages\n\n  const processContent = (content: unknown): unknown => {\n    if (typeof content === 'string') return content\n\n    if (!content) return content\n\n    if (Array.isArray(content)) {\n      return content.map(transformContent)\n    }\n\n    // Handle single object content\n    return transformContent(content)\n  }\n\n  const processMessage = (msg: unknown): unknown => {\n    if (!isObject(msg) || !('content' in msg)) return msg\n    return { ...msg, content: processContent(msg.content) }\n  }\n\n  // Handle both arrays and single messages\n  if (Array.isArray(messages)) {\n    return messages.map(processMessage)\n  }\n\n  return processMessage(messages)\n}\n\n// ============================================\n// Provider-Specific Image Sanitizers\n// ============================================\n\nconst sanitizeOpenAIImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle image_url format\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeOpenAIResponseImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle input_image format\n  if (item.type === 'input_image' && 'image_url' in item) {\n    return {\n      ...item,\n      image_url: redactBase64DataUrl(item.image_url),\n    }\n  }\n\n  return item\n}\n\nconst sanitizeAnthropicImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // Handle Anthropic's image format\n  if (\n    item.type === 'image' &&\n    'source' in item &&\n    isObject(item.source) &&\n    item.source.type === 'base64' &&\n    'data' in item.source\n  ) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return item\n}\n\nconst sanitizeGeminiPart = (part: unknown): unknown => {\n  if (!isObject(part)) return part\n\n  // Handle Gemini's inline data format\n  if ('inlineData' in part && isObject(part.inlineData) && 'data' in part.inlineData) {\n    return {\n      ...part,\n      inlineData: {\n        ...part.inlineData,\n        data: REDACTED_IMAGE_PLACEHOLDER,\n      },\n    }\n  }\n\n  return part\n}\n\nconst processGeminiItem = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // If it has parts, process them\n  if ('parts' in item && item.parts) {\n    const parts = Array.isArray(item.parts) ? item.parts.map(sanitizeGeminiPart) : sanitizeGeminiPart(item.parts)\n\n    return { ...item, parts }\n  }\n\n  return item\n}\n\nconst sanitizeLangChainImage = (item: unknown): unknown => {\n  if (!isObject(item)) return item\n\n  // OpenAI style\n  if (item.type === 'image_url' && 'image_url' in item && isObject(item.image_url) && 'url' in item.image_url) {\n    return {\n      ...item,\n      image_url: {\n        ...item.image_url,\n        url: redactBase64DataUrl(item.image_url.url),\n      },\n    }\n  }\n\n  // Direct image with data field\n  if (item.type === 'image' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  // Anthropic style\n  if (item.type === 'image' && 'source' in item && isObject(item.source) && 'data' in item.source) {\n    return {\n      ...item,\n      source: {\n        ...item.source,\n        data: redactBase64DataUrl(item.source.data),\n      },\n    }\n  }\n\n  // Google style\n  if (item.type === 'media' && 'data' in item) {\n    return { ...item, data: redactBase64DataUrl(item.data) }\n  }\n\n  return item\n}\n\n// Export individual sanitizers for tree-shaking\nexport const sanitizeOpenAI = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIImage)\n}\n\nexport const sanitizeOpenAIResponse = (data: unknown): unknown => {\n  return processMessages(data, sanitizeOpenAIResponseImage)\n}\n\nexport const sanitizeAnthropic = (data: unknown): unknown => {\n  return processMessages(data, sanitizeAnthropicImage)\n}\n\nexport const sanitizeGemini = (data: unknown): unknown => {\n  // Gemini has a different structure with 'parts' directly on items instead of 'content'\n  // So we need custom processing instead of using processMessages\n  if (!data) return data\n\n  if (Array.isArray(data)) {\n    return data.map(processGeminiItem)\n  }\n\n  return processGeminiItem(data)\n}\n\nexport const sanitizeLangChain = (data: unknown): unknown => {\n  return processMessages(data, sanitizeLangChainImage)\n}\n","import { wrapLanguageModel } from 'ai'\nimport type {\n  LanguageModelV2,\n  LanguageModelV2Content,\n  LanguageModelV2Middleware,\n  LanguageModelV2Prompt,\n  LanguageModelV2StreamPart,\n} from '@ai-sdk/provider'\nimport { v4 as uuidv4 } from 'uuid'\nimport { PostHog } from 'posthog-node'\nimport { CostOverride, sendEventToPosthog, truncate, MAX_OUTPUT_SIZE, extractAvailableToolCalls } from '../utils'\nimport { Buffer } from 'buffer'\nimport { redactBase64DataUrl } from '../sanitization'\nimport { isString } from '../typeGuards'\n\ninterface ClientOptions {\n  posthogDistinctId?: string\n  posthogTraceId?: string\n  posthogProperties?: Record<string, any>\n  posthogPrivacyMode?: boolean\n  posthogGroups?: Record<string, any>\n  posthogModelOverride?: string\n  posthogProviderOverride?: string\n  posthogCostOverride?: CostOverride\n  posthogCaptureImmediate?: boolean\n}\n\ninterface CreateInstrumentationMiddlewareOptions {\n  posthogDistinctId?: string\n  posthogTraceId?: string\n  posthogProperties?: Record<string, any>\n  posthogPrivacyMode?: boolean\n  posthogGroups?: Record<string, any>\n  posthogModelOverride?: string\n  posthogProviderOverride?: string\n  posthogCostOverride?: CostOverride\n  posthogCaptureImmediate?: boolean\n}\n\ninterface PostHogInput {\n  role: string\n  type?: string\n  content?:\n    | string\n    | {\n        [key: string]: any\n      }\n}\n\n// Content types for the output array\ntype OutputContentItem =\n  | { type: 'text'; text: string }\n  | { type: 'reasoning'; text: string }\n  | { type: 'tool-call'; id: string; function: { name: string; arguments: string } }\n  | { type: 'file'; name: string; mediaType: string; data: string }\n  | { type: 'source'; sourceType: string; id: string; url: string; title: string }\n\nconst mapVercelParams = (params: any): Record<string, any> => {\n  return {\n    temperature: params.temperature,\n    max_output_tokens: params.maxOutputTokens,\n    top_p: params.topP,\n    frequency_penalty: params.frequencyPenalty,\n    presence_penalty: params.presencePenalty,\n    stop: params.stopSequences,\n    stream: params.stream,\n  }\n}\n\nconst mapVercelPrompt = (messages: LanguageModelV2Prompt): PostHogInput[] => {\n  // Map and truncate individual content\n  const inputs: PostHogInput[] = messages.map((message) => {\n    let content: any\n\n    // Handle system role which has string content\n    if (message.role === 'system') {\n      content = [\n        {\n          type: 'text',\n          text: truncate(String(message.content)),\n        },\n      ]\n    } else {\n      // Handle other roles which have array content\n      if (Array.isArray(message.content)) {\n        content = message.content.map((c: any) => {\n          if (c.type === 'text') {\n            return {\n              type: 'text',\n              text: truncate(c.text),\n            }\n          } else if (c.type === 'file') {\n            // For file type, check if it's a data URL and redact if needed\n            let fileData: string\n\n            const contentData: unknown = c.data\n\n            if (contentData instanceof URL) {\n              fileData = contentData.toString()\n            } else if (isString(contentData)) {\n              // Redact base64 data URLs and raw base64 to prevent oversized events\n              fileData = redactBase64DataUrl(contentData)\n            } else {\n              fileData = 'raw files not supported'\n            }\n\n            return {\n              type: 'file',\n              file: fileData,\n              mediaType: c.mediaType,\n            }\n          } else if (c.type === 'reasoning') {\n            return {\n              type: 'reasoning',\n              text: truncate(c.reasoning),\n            }\n          } else if (c.type === 'tool-call') {\n            return {\n              type: 'tool-call',\n              toolCallId: c.toolCallId,\n              toolName: c.toolName,\n              input: c.input,\n            }\n          } else if (c.type === 'tool-result') {\n            return {\n              type: 'tool-result',\n              toolCallId: c.toolCallId,\n              toolName: c.toolName,\n              output: c.output,\n              isError: c.isError,\n            }\n          }\n          return {\n            type: 'text',\n            text: '',\n          }\n        })\n      } else {\n        // Fallback for non-array content\n        content = [\n          {\n            type: 'text',\n            text: truncate(String(message.content)),\n          },\n        ]\n      }\n    }\n\n    return {\n      role: message.role,\n      content,\n    }\n  })\n\n  try {\n    // Trim the inputs array until its JSON size fits within MAX_OUTPUT_SIZE\n    let serialized = JSON.stringify(inputs)\n    let removedCount = 0\n    // We need to keep track of the initial size of the inputs array because we're going to be mutating it\n    const initialSize = inputs.length\n    for (let i = 0; i < initialSize && Buffer.byteLength(serialized, 'utf8') > MAX_OUTPUT_SIZE; i++) {\n      inputs.shift()\n      removedCount++\n      serialized = JSON.stringify(inputs)\n    }\n    if (removedCount > 0) {\n      // Add one placeholder to indicate how many were removed\n      inputs.unshift({\n        role: 'posthog',\n        content: `[${removedCount} message${removedCount === 1 ? '' : 's'} removed due to size limit]`,\n      })\n    }\n  } catch (error) {\n    console.error('Error stringifying inputs', error)\n    return [{ role: 'posthog', content: 'An error occurred while processing your request. Please try again.' }]\n  }\n  return inputs\n}\n\nconst mapVercelOutput = (result: LanguageModelV2Content[]): PostHogInput[] => {\n  const content: OutputContentItem[] = result.map((item) => {\n    if (item.type === 'text') {\n      return { type: 'text', text: truncate(item.text) }\n    }\n    if (item.type === 'tool-call') {\n      return {\n        type: 'tool-call',\n        id: item.toolCallId,\n        function: {\n          name: item.toolName,\n          arguments: (item as any).args || JSON.stringify((item as any).arguments || {}),\n        },\n      }\n    }\n    if (item.type === 'reasoning') {\n      return { type: 'reasoning', text: truncate(item.text) }\n    }\n    if (item.type === 'file') {\n      // Handle files similar to input mapping - avoid large base64 data\n      let fileData: string\n      if (item.data instanceof URL) {\n        fileData = item.data.toString()\n      } else if (typeof item.data === 'string') {\n        fileData = redactBase64DataUrl(item.data)\n\n        // If not redacted and still large, replace with size indicator\n        if (fileData === item.data && item.data.length > 1000) {\n          fileData = `[${item.mediaType} file - ${item.data.length} bytes]`\n        }\n      } else {\n        fileData = `[binary ${item.mediaType} file]`\n      }\n\n      return {\n        type: 'file',\n        name: 'generated_file',\n        mediaType: item.mediaType,\n        data: fileData,\n      }\n    }\n    if (item.type === 'source') {\n      return {\n        type: 'source',\n        sourceType: item.sourceType,\n        id: item.id,\n        url: (item as any).url || '',\n        title: item.title || '',\n      }\n    }\n    // Fallback for unknown types - try to extract text if possible\n    return { type: 'text', text: truncate(JSON.stringify(item)) }\n  })\n\n  if (content.length > 0) {\n    return [\n      {\n        role: 'assistant',\n        content: content.length === 1 && content[0].type === 'text' ? content[0].text : content,\n      },\n    ]\n  }\n  // otherwise stringify and truncate\n  try {\n    const jsonOutput = JSON.stringify(result)\n    return [{ content: truncate(jsonOutput), role: 'assistant' }]\n  } catch {\n    console.error('Error stringifying output')\n    return []\n  }\n}\n\nconst extractProvider = (model: LanguageModelV2): string => {\n  const provider = model.provider.toLowerCase()\n  const providerName = provider.split('.')[0]\n  return providerName\n}\n\nexport const createInstrumentationMiddleware = (\n  phClient: PostHog,\n  model: LanguageModelV2,\n  options: CreateInstrumentationMiddlewareOptions\n): LanguageModelV2Middleware => {\n  const middleware: LanguageModelV2Middleware = {\n    wrapGenerate: async ({ doGenerate, params }) => {\n      const startTime = Date.now()\n      const mergedParams = {\n        ...options,\n        ...mapVercelParams(params),\n      }\n      const availableTools = extractAvailableToolCalls('vercel', params)\n\n      try {\n        const result = await doGenerate()\n        const modelId =\n          options.posthogModelOverride ?? (result.response?.modelId ? result.response.modelId : model.modelId)\n        const provider = options.posthogProviderOverride ?? extractProvider(model)\n        const baseURL = '' // cannot currently get baseURL from vercel\n        const content = mapVercelOutput(result.content)\n        const latency = (Date.now() - startTime) / 1000\n        const providerMetadata = result.providerMetadata\n        const additionalTokenValues = {\n          ...(providerMetadata?.anthropic\n            ? {\n                cacheCreationInputTokens: providerMetadata.anthropic.cacheCreationInputTokens,\n              }\n            : {}),\n        }\n        const usage = {\n          inputTokens: result.usage.inputTokens,\n          outputTokens: result.usage.outputTokens,\n          reasoningTokens: result.usage.reasoningTokens,\n          cacheReadInputTokens: result.usage.cachedInputTokens,\n          ...additionalTokenValues,\n        }\n        await sendEventToPosthog({\n          client: phClient,\n          distinctId: options.posthogDistinctId,\n          traceId: options.posthogTraceId ?? uuidv4(),\n          model: modelId,\n          provider: provider,\n          input: options.posthogPrivacyMode ? '' : mapVercelPrompt(params.prompt),\n          output: content,\n          latency,\n          baseURL,\n          params: mergedParams as any,\n          httpStatus: 200,\n          usage,\n          tools: availableTools,\n          captureImmediate: options.posthogCaptureImmediate,\n        })\n\n        return result\n      } catch (error: any) {\n        const modelId = model.modelId\n        await sendEventToPosthog({\n          client: phClient,\n          distinctId: options.posthogDistinctId,\n          traceId: options.posthogTraceId ?? uuidv4(),\n          model: modelId,\n          provider: model.provider,\n          input: options.posthogPrivacyMode ? '' : mapVercelPrompt(params.prompt),\n          output: [],\n          latency: 0,\n          baseURL: '',\n          params: mergedParams as any,\n          httpStatus: error?.status ? error.status : 500,\n          usage: {\n            inputTokens: 0,\n            outputTokens: 0,\n          },\n          isError: true,\n          error: truncate(JSON.stringify(error)),\n          tools: availableTools,\n          captureImmediate: options.posthogCaptureImmediate,\n        })\n        throw error\n      }\n    },\n\n    wrapStream: async ({ doStream, params }) => {\n      const startTime = Date.now()\n      let generatedText = ''\n      let reasoningText = ''\n      let usage: {\n        inputTokens?: number\n        outputTokens?: number\n        reasoningTokens?: any\n        cacheReadInputTokens?: any\n        cacheCreationInputTokens?: any\n      } = {}\n      const mergedParams = {\n        ...options,\n        ...mapVercelParams(params),\n      }\n\n      const modelId = options.posthogModelOverride ?? model.modelId\n      const provider = options.posthogProviderOverride ?? extractProvider(model)\n      const availableTools = extractAvailableToolCalls('vercel', params)\n      const baseURL = '' // cannot currently get baseURL from vercel\n\n      // Map to track in-progress tool calls\n      const toolCallsInProgress = new Map<\n        string,\n        {\n          toolCallId: string\n          toolName: string\n          input: string\n        }\n      >()\n\n      try {\n        const { stream, ...rest } = await doStream()\n        const transformStream = new TransformStream<LanguageModelV2StreamPart, LanguageModelV2StreamPart>({\n          transform(chunk, controller) {\n            // Handle new v5 streaming patterns\n            if (chunk.type === 'text-delta') {\n              generatedText += chunk.delta\n            }\n            if (chunk.type === 'reasoning-delta') {\n              reasoningText += chunk.delta // New in v5\n            }\n\n            // Handle tool call chunks\n            if (chunk.type === 'tool-input-start') {\n              // Initialize a new tool call\n              toolCallsInProgress.set(chunk.id, {\n                toolCallId: chunk.id,\n                toolName: chunk.toolName,\n                input: '',\n              })\n            }\n            if (chunk.type === 'tool-input-delta') {\n              // Accumulate tool call arguments\n              const toolCall = toolCallsInProgress.get(chunk.id)\n              if (toolCall) {\n                toolCall.input += chunk.delta\n              }\n            }\n            if (chunk.type === 'tool-input-end') {\n              // Tool call is complete, keep it in the map for final processing\n              // Nothing specific to do here, the tool call is already complete\n            }\n            if (chunk.type === 'tool-call') {\n              // Direct tool call chunk (complete tool call)\n              toolCallsInProgress.set(chunk.toolCallId, {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                input: chunk.input,\n              })\n            }\n\n            if (chunk.type === 'finish') {\n              const providerMetadata = chunk.providerMetadata\n              const additionalTokenValues = {\n                ...(providerMetadata?.anthropic\n                  ? {\n                      cacheCreationInputTokens: providerMetadata.anthropic.cacheCreationInputTokens,\n                    }\n                  : {}),\n              }\n              usage = {\n                inputTokens: chunk.usage?.inputTokens,\n                outputTokens: chunk.usage?.outputTokens,\n                reasoningTokens: chunk.usage?.reasoningTokens,\n                cacheReadInputTokens: chunk.usage?.cachedInputTokens,\n                ...additionalTokenValues,\n              }\n            }\n            controller.enqueue(chunk)\n          },\n\n          flush: async () => {\n            const latency = (Date.now() - startTime) / 1000\n            // Build content array similar to mapVercelOutput structure\n            const content: OutputContentItem[] = []\n            if (reasoningText) {\n              content.push({ type: 'reasoning', text: truncate(reasoningText) })\n            }\n            if (generatedText) {\n              content.push({ type: 'text', text: truncate(generatedText) })\n            }\n\n            // Add completed tool calls to content\n            for (const toolCall of toolCallsInProgress.values()) {\n              if (toolCall.toolName) {\n                content.push({\n                  type: 'tool-call',\n                  id: toolCall.toolCallId,\n                  function: {\n                    name: toolCall.toolName,\n                    arguments: toolCall.input,\n                  },\n                })\n              }\n            }\n\n            // Structure output like mapVercelOutput does\n            const output =\n              content.length > 0\n                ? [\n                    {\n                      role: 'assistant',\n                      content: content.length === 1 && content[0].type === 'text' ? content[0].text : content,\n                    },\n                  ]\n                : []\n\n            await sendEventToPosthog({\n              client: phClient,\n              distinctId: options.posthogDistinctId,\n              traceId: options.posthogTraceId ?? uuidv4(),\n              model: modelId,\n              provider: provider,\n              input: options.posthogPrivacyMode ? '' : mapVercelPrompt(params.prompt),\n              output: output,\n              latency,\n              baseURL,\n              params: mergedParams as any,\n              httpStatus: 200,\n              usage,\n              tools: availableTools,\n              captureImmediate: options.posthogCaptureImmediate,\n            })\n          },\n        })\n\n        return {\n          stream: stream.pipeThrough(transformStream),\n          ...rest,\n        }\n      } catch (error: any) {\n        await sendEventToPosthog({\n          client: phClient,\n          distinctId: options.posthogDistinctId,\n          traceId: options.posthogTraceId ?? uuidv4(),\n          model: modelId,\n          provider: provider,\n          input: options.posthogPrivacyMode ? '' : mapVercelPrompt(params.prompt),\n          output: [],\n          latency: 0,\n          baseURL: '',\n          params: mergedParams as any,\n          httpStatus: error?.status ? error.status : 500,\n          usage: {\n            inputTokens: 0,\n            outputTokens: 0,\n          },\n          isError: true,\n          error: truncate(JSON.stringify(error)),\n          tools: availableTools,\n          captureImmediate: options.posthogCaptureImmediate,\n        })\n        throw error\n      }\n    },\n  }\n\n  return middleware\n}\n\nexport const wrapVercelLanguageModel = (\n  model: LanguageModelV2,\n  phClient: PostHog,\n  options: ClientOptions\n): LanguageModelV2 => {\n  const traceId = options.posthogTraceId ?? uuidv4()\n  const middleware = createInstrumentationMiddleware(phClient, model, {\n    ...options,\n    posthogTraceId: traceId,\n    posthogDistinctId: options.posthogDistinctId,\n  })\n\n  const wrappedModel = wrapLanguageModel({\n    model,\n    middleware,\n  })\n\n  return wrappedModel\n}\n"],"names":["MAX_OUTPUT_SIZE","STRING_FORMAT","getModelParams","params","modelParams","paramKeys","key","undefined","withPrivacyMode","client","privacyMode","input","privacy_mode","toSafeString","JSON","stringify","console","warn","truncate","str","encoder","TextEncoder","buffer","encode","length","TextDecoder","decode","truncatedBuffer","slice","decoder","fatal","truncatedStr","endsWith","extractAvailableToolCalls","provider","tools","AIEvent","sanitizeValues","obj","jsonSafe","parse","Buffer","from","toString","Array","isArray","map","Object","fromEntries","entries","k","v","sendEventToPosthog","eventType","Generation","distinctId","traceId","model","output","latency","baseURL","httpStatus","usage","isError","error","captureImmediate","capture","Promise","resolve","safeInput","safeOutput","safeError","errorData","$ai_is_error","$ai_error","costOverrideData","posthogCostOverride","inputCostUSD","inputCost","inputTokens","outputCostUSD","outputCost","outputTokens","$ai_input_cost_usd","$ai_output_cost_usd","$ai_total_cost_usd","additionalTokenValues","reasoningTokens","$ai_reasoning_tokens","cacheReadInputTokens","$ai_cache_read_input_tokens","cacheCreationInputTokens","$ai_cache_creation_input_tokens","properties","$ai_lib","$ai_lib_version","version","$ai_provider","posthogProviderOverride","$ai_model","posthogModelOverride","$ai_model_parameters","$ai_input","posthogPrivacyMode","$ai_output_choices","$ai_http_status","$ai_input_tokens","$ai_output_tokens","$ai_latency","$ai_trace_id","$ai_base_url","posthogProperties","$process_person_profile","$ai_tools","event","groups","posthogGroups","isString","value","REDACTED_IMAGE_PLACEHOLDER","isBase64DataUrl","test","isValidUrl","URL","startsWith","isRawBase64","redactBase64DataUrl","mapVercelParams","temperature","max_output_tokens","maxOutputTokens","top_p","topP","frequency_penalty","frequencyPenalty","presence_penalty","presencePenalty","stop","stopSequences","stream","mapVercelPrompt","messages","inputs","message","content","role","type","text","String","c","fileData","contentData","data","file","mediaType","reasoning","toolCallId","toolName","serialized","removedCount","initialSize","i","byteLength","shift","unshift","mapVercelOutput","result","item","id","function","name","arguments","args","sourceType","url","title","jsonOutput","extractProvider","toLowerCase","providerName","split","createInstrumentationMiddleware","phClient","options","middleware","wrapGenerate","doGenerate","startTime","Date","now","mergedParams","availableTools","modelId","response","providerMetadata","anthropic","cachedInputTokens","posthogDistinctId","posthogTraceId","uuidv4","prompt","posthogCaptureImmediate","status","wrapStream","doStream","generatedText","reasoningText","toolCallsInProgress","Map","rest","transformStream","TransformStream","transform","chunk","controller","delta","set","toolCall","get","enqueue","flush","push","values","pipeThrough","wrapVercelLanguageModel","wrappedModel","wrapLanguageModel"],"mappings":"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"}